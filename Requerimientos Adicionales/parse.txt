Grammar:

Rule 0     S' -> program
Rule 1     program -> error
Rule 2     program -> stmt
Rule 3     program -> program stmt
Rule 4     stmt -> NEWLINE
Rule 5     stmt -> INTEGER NEWLINE
Rule 6     stmt -> INTEGER error NEWLINE
Rule 7     stmt -> INTEGER command NEWLINE
Rule 8     command -> DIM error
Rule 9     command -> DIM dimlist
Rule 10    command -> RETURN
Rule 11    command -> GOSUB error
Rule 12    command -> GOSUB INTEGER
Rule 13    command -> DEF FNAME ( error ) = expr
Rule 14    command -> DEF FNAME ( IDENT ) = error
Rule 15    command -> DEF FNAME ( IDENT ) = expr
Rule 16    command -> STOP
Rule 17    command -> REM
Rule 18    command -> END
Rule 19    command -> NEXT error
Rule 20    command -> NEXT IDENT
Rule 21    command -> FOR IDENT = expr TO error optstep
Rule 22    command -> FOR IDENT = error TO expr optstep
Rule 23    command -> FOR IDENT = expr TO expr optstep
Rule 24    command -> IF error THEN INTEGER
Rule 25    command -> IF relexpr THEN error
Rule 26    command -> IF relexpr THEN INTEGER
Rule 27    command -> GOTO error
Rule 28    command -> GOTO INTEGER
Rule 29    command -> PRINT error
Rule 30    command -> PRINT
Rule 31    command -> PRINT plist optend
Rule 32    command -> INPUT error
Rule 33    command -> INPUT _1_STRING_sep_optional varlist
Rule 34    _1_STRING_sep_optional -> STRING sep
Rule 35    _1_STRING_sep_optional -> <empty>
Rule 36    command -> DATA error
Rule 37    command -> DATA mixedlist
Rule 38    command -> READ error
Rule 39    command -> RESTORE
Rule 40    command -> READ varlist
Rule 41    command -> LET variable = error
Rule 42    command -> LET variable = expr
Rule 43    command -> command
Rule 44    mixedlist -> mixedlist , mixeditem
Rule 45    mixedlist -> mixeditem
Rule 46    mixeditem -> STRING
Rule 47    mixeditem -> number
Rule 48    optend -> empty
Rule 49    optend -> sep
Rule 50    expr -> - expr  [precedence=right, level=5]
Rule 51    expr -> ( expr )
Rule 52    expr -> FNAME ( exprlist )
Rule 53    expr -> BLTIN ( exprlist )
Rule 54    expr -> BLTIN ( )
Rule 55    expr -> variable
Rule 56    expr -> STRING
Rule 57    expr -> FLOAT
Rule 58    expr -> INTEGER
Rule 59    expr -> expr % expr  [precedence=left, level=4]
Rule 60    expr -> expr ^ expr  [precedence=left, level=3]
Rule 61    expr -> expr / expr  [precedence=left, level=2]
Rule 62    expr -> expr * expr  [precedence=left, level=2]
Rule 63    expr -> expr - expr  [precedence=left, level=1]
Rule 64    expr -> expr + expr  [precedence=left, level=1]
Rule 65    exprlist -> exprlist , expr
Rule 66    exprlist -> expr
Rule 67    relexpr -> expr NE expr
Rule 68    relexpr -> expr = expr
Rule 69    relexpr -> expr GE expr
Rule 70    relexpr -> expr GT expr
Rule 71    relexpr -> expr LE expr
Rule 72    relexpr -> expr LT expr
Rule 73    variable -> IDENT ( expr , expr )
Rule 74    variable -> IDENT ( expr )
Rule 75    variable -> IDENT
Rule 76    optstep -> empty
Rule 77    optstep -> STEP expr
Rule 78    dimitem -> IDENT ( INTEGER , INTEGER )
Rule 79    dimitem -> IDENT ( INTEGER )
Rule 80    dimlist -> dimlist , dimitem
Rule 81    dimlist -> dimitem
Rule 82    varlist -> varlist , variable
Rule 83    varlist -> variable
Rule 84    number -> - FLOAT  [precedence=right, level=5]
Rule 85    number -> - INTEGER  [precedence=right, level=5]
Rule 86    number -> FLOAT
Rule 87    number -> INTEGER
Rule 88    plist -> plist sep pitem
Rule 89    plist -> pitem
Rule 90    pitem -> expr
Rule 91    pitem -> STRING expr
Rule 92    sep -> ;
Rule 93    sep -> ,
Rule 94    empty -> <empty>

Terminals, with rules where they appear:

%                    : 59
(                    : 13 14 15 51 52 53 54 73 74 78 79
)                    : 13 14 15 51 52 53 54 73 74 78 79
*                    : 62
+                    : 64
,                    : 44 65 73 78 80 82 93
-                    : 50 63 84 85
/                    : 61
;                    : 92
=                    : 13 14 15 21 22 23 41 42 68
BLTIN                : 53 54
DATA                 : 36 37
DEF                  : 13 14 15
DIM                  : 8 9
END                  : 18
FLOAT                : 57 84 86
FNAME                : 13 14 15 52
FOR                  : 21 22 23
GE                   : 69
GOSUB                : 11 12
GOTO                 : 27 28
GT                   : 70
IDENT                : 14 15 20 21 22 23 73 74 75 78 79
IF                   : 24 25 26
INPUT                : 32 33
INTEGER              : 5 6 7 12 24 26 28 58 78 78 79 85 87
LE                   : 71
LET                  : 41 42
LT                   : 72
NE                   : 67
NEWLINE              : 4 5 6 7
NEXT                 : 19 20
PRINT                : 29 30 31
READ                 : 38 40
REM                  : 17
RESTORE              : 39
RETURN               : 10
STEP                 : 77
STOP                 : 16
STRING               : 34 46 56 91
THEN                 : 24 25 26
TO                   : 21 22 23
^                    : 60
error                : 1 6 8 11 13 14 19 21 22 24 25 27 29 32 36 38 41

Nonterminals, with rules where they appear:

_1_STRING_sep_optional : 33
command              : 7 43
dimitem              : 80 81
dimlist              : 9 80
empty                : 48 76
expr                 : 13 15 21 22 23 23 42 50 51 59 59 60 60 61 61 62 62 63 63 64 64 65 66 67 67 68 68 69 69 70 70 71 71 72 72 73 73 74 77 90 91
exprlist             : 52 53 65
mixeditem            : 44 45
mixedlist            : 37 44
number               : 47
optend               : 31
optstep              : 21 22 23
pitem                : 88 89
plist                : 31 88
program              : 3 0
relexpr              : 25 26
sep                  : 34 49 88
stmt                 : 2 3
variable             : 41 42 55 82 83
varlist              : 33 40 82


state 0

    (0) S' -> . program
    (1) program -> . error
    (2) program -> . stmt
    (3) program -> . program stmt
    (4) stmt -> . NEWLINE
    (5) stmt -> . INTEGER NEWLINE
    (6) stmt -> . INTEGER error NEWLINE
    (7) stmt -> . INTEGER command NEWLINE
    error           shift and go to state 2
    NEWLINE         shift and go to state 4
    INTEGER         shift and go to state 5

    program                        shift and go to state 1
    stmt                           shift and go to state 3

state 1

    (0) S' -> program .
    (3) program -> program . stmt
    (4) stmt -> . NEWLINE
    (5) stmt -> . INTEGER NEWLINE
    (6) stmt -> . INTEGER error NEWLINE
    (7) stmt -> . INTEGER command NEWLINE
    NEWLINE         shift and go to state 4
    INTEGER         shift and go to state 5

    stmt                           shift and go to state 6

state 2

    (1) program -> error .
    NEWLINE         reduce using rule 1 (program -> error .)
    INTEGER         reduce using rule 1 (program -> error .)
    $end            reduce using rule 1 (program -> error .)


state 3

    (2) program -> stmt .
    NEWLINE         reduce using rule 2 (program -> stmt .)
    INTEGER         reduce using rule 2 (program -> stmt .)
    $end            reduce using rule 2 (program -> stmt .)


state 4

    (4) stmt -> NEWLINE .
    NEWLINE         reduce using rule 4 (stmt -> NEWLINE .)
    INTEGER         reduce using rule 4 (stmt -> NEWLINE .)
    $end            reduce using rule 4 (stmt -> NEWLINE .)


state 5

    (5) stmt -> INTEGER . NEWLINE
    (6) stmt -> INTEGER . error NEWLINE
    (7) stmt -> INTEGER . command NEWLINE
    (8) command -> . DIM error
    (9) command -> . DIM dimlist
    (10) command -> . RETURN
    (11) command -> . GOSUB error
    (12) command -> . GOSUB INTEGER
    (13) command -> . DEF FNAME ( error ) = expr
    (14) command -> . DEF FNAME ( IDENT ) = error
    (15) command -> . DEF FNAME ( IDENT ) = expr
    (16) command -> . STOP
    (17) command -> . REM
    (18) command -> . END
    (19) command -> . NEXT error
    (20) command -> . NEXT IDENT
    (21) command -> . FOR IDENT = expr TO error optstep
    (22) command -> . FOR IDENT = error TO expr optstep
    (23) command -> . FOR IDENT = expr TO expr optstep
    (24) command -> . IF error THEN INTEGER
    (25) command -> . IF relexpr THEN error
    (26) command -> . IF relexpr THEN INTEGER
    (27) command -> . GOTO error
    (28) command -> . GOTO INTEGER
    (29) command -> . PRINT error
    (30) command -> . PRINT
    (31) command -> . PRINT plist optend
    (32) command -> . INPUT error
    (33) command -> . INPUT _1_STRING_sep_optional varlist
    (36) command -> . DATA error
    (37) command -> . DATA mixedlist
    (38) command -> . READ error
    (39) command -> . RESTORE
    (40) command -> . READ varlist
    (41) command -> . LET variable = error
    (42) command -> . LET variable = expr
    (43) command -> . command
    NEWLINE         shift and go to state 7
    error           shift and go to state 8
    DIM             shift and go to state 10
    RETURN          shift and go to state 11
    GOSUB           shift and go to state 12
    DEF             shift and go to state 13
    STOP            shift and go to state 14
    REM             shift and go to state 15
    END             shift and go to state 16
    NEXT            shift and go to state 17
    FOR             shift and go to state 18
    IF              shift and go to state 19
    GOTO            shift and go to state 20
    PRINT           shift and go to state 21
    INPUT           shift and go to state 22
    DATA            shift and go to state 23
    READ            shift and go to state 24
    RESTORE         shift and go to state 25
    LET             shift and go to state 26

    command                        shift and go to state 9

state 6

    (3) program -> program stmt .
    NEWLINE         reduce using rule 3 (program -> program stmt .)
    INTEGER         reduce using rule 3 (program -> program stmt .)
    $end            reduce using rule 3 (program -> program stmt .)


state 7

    (5) stmt -> INTEGER NEWLINE .
    NEWLINE         reduce using rule 5 (stmt -> INTEGER NEWLINE .)
    INTEGER         reduce using rule 5 (stmt -> INTEGER NEWLINE .)
    $end            reduce using rule 5 (stmt -> INTEGER NEWLINE .)


state 8

    (6) stmt -> INTEGER error . NEWLINE
    NEWLINE         shift and go to state 27


state 9

    (7) stmt -> INTEGER command . NEWLINE
    (43) command -> command .
  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 28


state 10

    (8) command -> DIM . error
    (9) command -> DIM . dimlist
    (80) dimlist -> . dimlist , dimitem
    (81) dimlist -> . dimitem
    (78) dimitem -> . IDENT ( INTEGER , INTEGER )
    (79) dimitem -> . IDENT ( INTEGER )
    error           shift and go to state 29
    IDENT           shift and go to state 32

    dimlist                        shift and go to state 30
    dimitem                        shift and go to state 31

state 11

    (10) command -> RETURN .
    NEWLINE         reduce using rule 10 (command -> RETURN .)


state 12

    (11) command -> GOSUB . error
    (12) command -> GOSUB . INTEGER
    error           shift and go to state 33
    INTEGER         shift and go to state 34


state 13

    (13) command -> DEF . FNAME ( error ) = expr
    (14) command -> DEF . FNAME ( IDENT ) = error
    (15) command -> DEF . FNAME ( IDENT ) = expr
    FNAME           shift and go to state 35


state 14

    (16) command -> STOP .
    NEWLINE         reduce using rule 16 (command -> STOP .)


state 15

    (17) command -> REM .
    NEWLINE         reduce using rule 17 (command -> REM .)


state 16

    (18) command -> END .
    NEWLINE         reduce using rule 18 (command -> END .)


state 17

    (19) command -> NEXT . error
    (20) command -> NEXT . IDENT
    error           shift and go to state 36
    IDENT           shift and go to state 37


state 18

    (21) command -> FOR . IDENT = expr TO error optstep
    (22) command -> FOR . IDENT = error TO expr optstep
    (23) command -> FOR . IDENT = expr TO expr optstep
    IDENT           shift and go to state 38


state 19

    (24) command -> IF . error THEN INTEGER
    (25) command -> IF . relexpr THEN error
    (26) command -> IF . relexpr THEN INTEGER
    (67) relexpr -> . expr NE expr
    (68) relexpr -> . expr = expr
    (69) relexpr -> . expr GE expr
    (70) relexpr -> . expr GT expr
    (71) relexpr -> . expr LE expr
    (72) relexpr -> . expr LT expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    error           shift and go to state 39
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    relexpr                        shift and go to state 41
    expr                           shift and go to state 42
    variable                       shift and go to state 47

state 20

    (27) command -> GOTO . error
    (28) command -> GOTO . INTEGER
    error           shift and go to state 51
    INTEGER         shift and go to state 52


state 21

    (29) command -> PRINT . error
    (30) command -> PRINT .
    (31) command -> PRINT . plist optend
    (88) plist -> . plist sep pitem
    (89) plist -> . pitem
    (90) pitem -> . expr
    (91) pitem -> . STRING expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    error           shift and go to state 53
    NEWLINE         reduce using rule 30 (command -> PRINT .)
    STRING          shift and go to state 57
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    plist                          shift and go to state 54
    pitem                          shift and go to state 55
    expr                           shift and go to state 56
    variable                       shift and go to state 47

state 22

    (32) command -> INPUT . error
    (33) command -> INPUT . _1_STRING_sep_optional varlist
    (34) _1_STRING_sep_optional -> . STRING sep
    (35) _1_STRING_sep_optional -> .
    error           shift and go to state 58
    STRING          shift and go to state 60
    IDENT           reduce using rule 35 (_1_STRING_sep_optional -> .)

    _1_STRING_sep_optional         shift and go to state 59

state 23

    (36) command -> DATA . error
    (37) command -> DATA . mixedlist
    (44) mixedlist -> . mixedlist , mixeditem
    (45) mixedlist -> . mixeditem
    (46) mixeditem -> . STRING
    (47) mixeditem -> . number
    (84) number -> . - FLOAT
    (85) number -> . - INTEGER
    (86) number -> . FLOAT
    (87) number -> . INTEGER
    error           shift and go to state 61
    STRING          shift and go to state 64
    -               shift and go to state 66
    FLOAT           shift and go to state 67
    INTEGER         shift and go to state 68

    mixedlist                      shift and go to state 62
    mixeditem                      shift and go to state 63
    number                         shift and go to state 65

state 24

    (38) command -> READ . error
    (40) command -> READ . varlist
    (82) varlist -> . varlist , variable
    (83) varlist -> . variable
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    error           shift and go to state 69
    IDENT           shift and go to state 50

    varlist                        shift and go to state 70
    variable                       shift and go to state 71

state 25

    (39) command -> RESTORE .
    NEWLINE         reduce using rule 39 (command -> RESTORE .)


state 26

    (41) command -> LET . variable = error
    (42) command -> LET . variable = expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    IDENT           shift and go to state 50

    variable                       shift and go to state 72

state 27

    (6) stmt -> INTEGER error NEWLINE .
    NEWLINE         reduce using rule 6 (stmt -> INTEGER error NEWLINE .)
    INTEGER         reduce using rule 6 (stmt -> INTEGER error NEWLINE .)
    $end            reduce using rule 6 (stmt -> INTEGER error NEWLINE .)


state 28

    (7) stmt -> INTEGER command NEWLINE .
    NEWLINE         reduce using rule 7 (stmt -> INTEGER command NEWLINE .)
    INTEGER         reduce using rule 7 (stmt -> INTEGER command NEWLINE .)
    $end            reduce using rule 7 (stmt -> INTEGER command NEWLINE .)


state 29

    (8) command -> DIM error .
    NEWLINE         reduce using rule 8 (command -> DIM error .)


state 30

    (9) command -> DIM dimlist .
    (80) dimlist -> dimlist . , dimitem
    NEWLINE         reduce using rule 9 (command -> DIM dimlist .)
    ,               shift and go to state 73


state 31

    (81) dimlist -> dimitem .
    ,               reduce using rule 81 (dimlist -> dimitem .)
    NEWLINE         reduce using rule 81 (dimlist -> dimitem .)


state 32

    (78) dimitem -> IDENT . ( INTEGER , INTEGER )
    (79) dimitem -> IDENT . ( INTEGER )
    (               shift and go to state 74


state 33

    (11) command -> GOSUB error .
    NEWLINE         reduce using rule 11 (command -> GOSUB error .)


state 34

    (12) command -> GOSUB INTEGER .
    NEWLINE         reduce using rule 12 (command -> GOSUB INTEGER .)


state 35

    (13) command -> DEF FNAME . ( error ) = expr
    (14) command -> DEF FNAME . ( IDENT ) = error
    (15) command -> DEF FNAME . ( IDENT ) = expr
    (               shift and go to state 75


state 36

    (19) command -> NEXT error .
    NEWLINE         reduce using rule 19 (command -> NEXT error .)


state 37

    (20) command -> NEXT IDENT .
    NEWLINE         reduce using rule 20 (command -> NEXT IDENT .)


state 38

    (21) command -> FOR IDENT . = expr TO error optstep
    (22) command -> FOR IDENT . = error TO expr optstep
    (23) command -> FOR IDENT . = expr TO expr optstep
    =               shift and go to state 76


state 39

    (24) command -> IF error . THEN INTEGER
    THEN            shift and go to state 77


state 40

    (58) expr -> INTEGER .
    NE              reduce using rule 58 (expr -> INTEGER .)
    =               reduce using rule 58 (expr -> INTEGER .)
    GE              reduce using rule 58 (expr -> INTEGER .)
    GT              reduce using rule 58 (expr -> INTEGER .)
    LE              reduce using rule 58 (expr -> INTEGER .)
    LT              reduce using rule 58 (expr -> INTEGER .)
    %               reduce using rule 58 (expr -> INTEGER .)
    ^               reduce using rule 58 (expr -> INTEGER .)
    /               reduce using rule 58 (expr -> INTEGER .)
    *               reduce using rule 58 (expr -> INTEGER .)
    -               reduce using rule 58 (expr -> INTEGER .)
    +               reduce using rule 58 (expr -> INTEGER .)
    ;               reduce using rule 58 (expr -> INTEGER .)
    ,               reduce using rule 58 (expr -> INTEGER .)
    NEWLINE         reduce using rule 58 (expr -> INTEGER .)
    )               reduce using rule 58 (expr -> INTEGER .)
    TO              reduce using rule 58 (expr -> INTEGER .)
    THEN            reduce using rule 58 (expr -> INTEGER .)
    STEP            reduce using rule 58 (expr -> INTEGER .)


state 41

    (25) command -> IF relexpr . THEN error
    (26) command -> IF relexpr . THEN INTEGER
    THEN            shift and go to state 78


state 42

    (67) relexpr -> expr . NE expr
    (68) relexpr -> expr . = expr
    (69) relexpr -> expr . GE expr
    (70) relexpr -> expr . GT expr
    (71) relexpr -> expr . LE expr
    (72) relexpr -> expr . LT expr
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NE              shift and go to state 79
    =               shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 43

    (50) expr -> - . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 91
    variable                       shift and go to state 47

state 44

    (51) expr -> ( . expr )
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 92
    variable                       shift and go to state 47

state 45

    (52) expr -> FNAME . ( exprlist )
    (               shift and go to state 93


state 46

    (53) expr -> BLTIN . ( exprlist )
    (54) expr -> BLTIN . ( )
    (               shift and go to state 94


state 47

    (55) expr -> variable .
    NE              reduce using rule 55 (expr -> variable .)
    =               reduce using rule 55 (expr -> variable .)
    GE              reduce using rule 55 (expr -> variable .)
    GT              reduce using rule 55 (expr -> variable .)
    LE              reduce using rule 55 (expr -> variable .)
    LT              reduce using rule 55 (expr -> variable .)
    %               reduce using rule 55 (expr -> variable .)
    ^               reduce using rule 55 (expr -> variable .)
    /               reduce using rule 55 (expr -> variable .)
    *               reduce using rule 55 (expr -> variable .)
    -               reduce using rule 55 (expr -> variable .)
    +               reduce using rule 55 (expr -> variable .)
    ;               reduce using rule 55 (expr -> variable .)
    ,               reduce using rule 55 (expr -> variable .)
    NEWLINE         reduce using rule 55 (expr -> variable .)
    )               reduce using rule 55 (expr -> variable .)
    TO              reduce using rule 55 (expr -> variable .)
    THEN            reduce using rule 55 (expr -> variable .)
    STEP            reduce using rule 55 (expr -> variable .)


state 48

    (56) expr -> STRING .
    NE              reduce using rule 56 (expr -> STRING .)
    =               reduce using rule 56 (expr -> STRING .)
    GE              reduce using rule 56 (expr -> STRING .)
    GT              reduce using rule 56 (expr -> STRING .)
    LE              reduce using rule 56 (expr -> STRING .)
    LT              reduce using rule 56 (expr -> STRING .)
    %               reduce using rule 56 (expr -> STRING .)
    ^               reduce using rule 56 (expr -> STRING .)
    /               reduce using rule 56 (expr -> STRING .)
    *               reduce using rule 56 (expr -> STRING .)
    -               reduce using rule 56 (expr -> STRING .)
    +               reduce using rule 56 (expr -> STRING .)
    ;               reduce using rule 56 (expr -> STRING .)
    ,               reduce using rule 56 (expr -> STRING .)
    NEWLINE         reduce using rule 56 (expr -> STRING .)
    )               reduce using rule 56 (expr -> STRING .)
    TO              reduce using rule 56 (expr -> STRING .)
    THEN            reduce using rule 56 (expr -> STRING .)
    STEP            reduce using rule 56 (expr -> STRING .)


state 49

    (57) expr -> FLOAT .
    NE              reduce using rule 57 (expr -> FLOAT .)
    =               reduce using rule 57 (expr -> FLOAT .)
    GE              reduce using rule 57 (expr -> FLOAT .)
    GT              reduce using rule 57 (expr -> FLOAT .)
    LE              reduce using rule 57 (expr -> FLOAT .)
    LT              reduce using rule 57 (expr -> FLOAT .)
    %               reduce using rule 57 (expr -> FLOAT .)
    ^               reduce using rule 57 (expr -> FLOAT .)
    /               reduce using rule 57 (expr -> FLOAT .)
    *               reduce using rule 57 (expr -> FLOAT .)
    -               reduce using rule 57 (expr -> FLOAT .)
    +               reduce using rule 57 (expr -> FLOAT .)
    ;               reduce using rule 57 (expr -> FLOAT .)
    ,               reduce using rule 57 (expr -> FLOAT .)
    NEWLINE         reduce using rule 57 (expr -> FLOAT .)
    )               reduce using rule 57 (expr -> FLOAT .)
    TO              reduce using rule 57 (expr -> FLOAT .)
    THEN            reduce using rule 57 (expr -> FLOAT .)
    STEP            reduce using rule 57 (expr -> FLOAT .)


state 50

    (73) variable -> IDENT . ( expr , expr )
    (74) variable -> IDENT . ( expr )
    (75) variable -> IDENT .
    (               shift and go to state 95
    NE              reduce using rule 75 (variable -> IDENT .)
    =               reduce using rule 75 (variable -> IDENT .)
    GE              reduce using rule 75 (variable -> IDENT .)
    GT              reduce using rule 75 (variable -> IDENT .)
    LE              reduce using rule 75 (variable -> IDENT .)
    LT              reduce using rule 75 (variable -> IDENT .)
    %               reduce using rule 75 (variable -> IDENT .)
    ^               reduce using rule 75 (variable -> IDENT .)
    /               reduce using rule 75 (variable -> IDENT .)
    *               reduce using rule 75 (variable -> IDENT .)
    -               reduce using rule 75 (variable -> IDENT .)
    +               reduce using rule 75 (variable -> IDENT .)
    ;               reduce using rule 75 (variable -> IDENT .)
    ,               reduce using rule 75 (variable -> IDENT .)
    NEWLINE         reduce using rule 75 (variable -> IDENT .)
    )               reduce using rule 75 (variable -> IDENT .)
    TO              reduce using rule 75 (variable -> IDENT .)
    THEN            reduce using rule 75 (variable -> IDENT .)
    STEP            reduce using rule 75 (variable -> IDENT .)


state 51

    (27) command -> GOTO error .
    NEWLINE         reduce using rule 27 (command -> GOTO error .)


state 52

    (28) command -> GOTO INTEGER .
    NEWLINE         reduce using rule 28 (command -> GOTO INTEGER .)


state 53

    (29) command -> PRINT error .
    NEWLINE         reduce using rule 29 (command -> PRINT error .)


state 54

    (31) command -> PRINT plist . optend
    (88) plist -> plist . sep pitem
    (48) optend -> . empty
    (49) optend -> . sep
    (92) sep -> . ;
    (93) sep -> . ,
    (94) empty -> .
    ;               shift and go to state 99
    ,               shift and go to state 100
    NEWLINE         reduce using rule 94 (empty -> .)

    optend                         shift and go to state 96
    sep                            shift and go to state 97
    empty                          shift and go to state 98

state 55

    (89) plist -> pitem .
    ;               reduce using rule 89 (plist -> pitem .)
    ,               reduce using rule 89 (plist -> pitem .)
    NEWLINE         reduce using rule 89 (plist -> pitem .)


state 56

    (90) pitem -> expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    ;               reduce using rule 90 (pitem -> expr .)
    ,               reduce using rule 90 (pitem -> expr .)
    NEWLINE         reduce using rule 90 (pitem -> expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 57

    (91) pitem -> STRING . expr
    (56) expr -> STRING .
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
  ! shift/reduce conflict for - resolved as shift
    %               reduce using rule 56 (expr -> STRING .)
    ^               reduce using rule 56 (expr -> STRING .)
    /               reduce using rule 56 (expr -> STRING .)
    *               reduce using rule 56 (expr -> STRING .)
    +               reduce using rule 56 (expr -> STRING .)
    ;               reduce using rule 56 (expr -> STRING .)
    ,               reduce using rule 56 (expr -> STRING .)
    NEWLINE         reduce using rule 56 (expr -> STRING .)
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 101
    variable                       shift and go to state 47

state 58

    (32) command -> INPUT error .
    NEWLINE         reduce using rule 32 (command -> INPUT error .)


state 59

    (33) command -> INPUT _1_STRING_sep_optional . varlist
    (82) varlist -> . varlist , variable
    (83) varlist -> . variable
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    IDENT           shift and go to state 50

    varlist                        shift and go to state 102
    variable                       shift and go to state 71

state 60

    (34) _1_STRING_sep_optional -> STRING . sep
    (92) sep -> . ;
    (93) sep -> . ,
    ;               shift and go to state 99
    ,               shift and go to state 100

    sep                            shift and go to state 103

state 61

    (36) command -> DATA error .
    NEWLINE         reduce using rule 36 (command -> DATA error .)


state 62

    (37) command -> DATA mixedlist .
    (44) mixedlist -> mixedlist . , mixeditem
    NEWLINE         reduce using rule 37 (command -> DATA mixedlist .)
    ,               shift and go to state 104


state 63

    (45) mixedlist -> mixeditem .
    ,               reduce using rule 45 (mixedlist -> mixeditem .)
    NEWLINE         reduce using rule 45 (mixedlist -> mixeditem .)


state 64

    (46) mixeditem -> STRING .
    ,               reduce using rule 46 (mixeditem -> STRING .)
    NEWLINE         reduce using rule 46 (mixeditem -> STRING .)


state 65

    (47) mixeditem -> number .
    ,               reduce using rule 47 (mixeditem -> number .)
    NEWLINE         reduce using rule 47 (mixeditem -> number .)


state 66

    (84) number -> - . FLOAT
    (85) number -> - . INTEGER
    FLOAT           shift and go to state 105
    INTEGER         shift and go to state 106


state 67

    (86) number -> FLOAT .
    ,               reduce using rule 86 (number -> FLOAT .)
    NEWLINE         reduce using rule 86 (number -> FLOAT .)


state 68

    (87) number -> INTEGER .
    ,               reduce using rule 87 (number -> INTEGER .)
    NEWLINE         reduce using rule 87 (number -> INTEGER .)


state 69

    (38) command -> READ error .
    NEWLINE         reduce using rule 38 (command -> READ error .)


state 70

    (40) command -> READ varlist .
    (82) varlist -> varlist . , variable
    NEWLINE         reduce using rule 40 (command -> READ varlist .)
    ,               shift and go to state 107


state 71

    (83) varlist -> variable .
    ,               reduce using rule 83 (varlist -> variable .)
    NEWLINE         reduce using rule 83 (varlist -> variable .)


state 72

    (41) command -> LET variable . = error
    (42) command -> LET variable . = expr
    =               shift and go to state 108


state 73

    (80) dimlist -> dimlist , . dimitem
    (78) dimitem -> . IDENT ( INTEGER , INTEGER )
    (79) dimitem -> . IDENT ( INTEGER )
    IDENT           shift and go to state 32

    dimitem                        shift and go to state 109

state 74

    (78) dimitem -> IDENT ( . INTEGER , INTEGER )
    (79) dimitem -> IDENT ( . INTEGER )
    INTEGER         shift and go to state 110


state 75

    (13) command -> DEF FNAME ( . error ) = expr
    (14) command -> DEF FNAME ( . IDENT ) = error
    (15) command -> DEF FNAME ( . IDENT ) = expr
    error           shift and go to state 111
    IDENT           shift and go to state 112


state 76

    (21) command -> FOR IDENT = . expr TO error optstep
    (22) command -> FOR IDENT = . error TO expr optstep
    (23) command -> FOR IDENT = . expr TO expr optstep
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    error           shift and go to state 114
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 113
    variable                       shift and go to state 47

state 77

    (24) command -> IF error THEN . INTEGER
    INTEGER         shift and go to state 115


state 78

    (25) command -> IF relexpr THEN . error
    (26) command -> IF relexpr THEN . INTEGER
    error           shift and go to state 116
    INTEGER         shift and go to state 117


state 79

    (67) relexpr -> expr NE . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 118
    variable                       shift and go to state 47

state 80

    (68) relexpr -> expr = . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 119
    variable                       shift and go to state 47

state 81

    (69) relexpr -> expr GE . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 120
    variable                       shift and go to state 47

state 82

    (70) relexpr -> expr GT . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 121
    variable                       shift and go to state 47

state 83

    (71) relexpr -> expr LE . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 122
    variable                       shift and go to state 47

state 84

    (72) relexpr -> expr LT . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 123
    variable                       shift and go to state 47

state 85

    (59) expr -> expr % . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 124
    variable                       shift and go to state 47

state 86

    (60) expr -> expr ^ . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 125
    variable                       shift and go to state 47

state 87

    (61) expr -> expr / . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 126
    variable                       shift and go to state 47

state 88

    (62) expr -> expr * . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 127
    variable                       shift and go to state 47

state 89

    (63) expr -> expr - . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 128
    variable                       shift and go to state 47

state 90

    (64) expr -> expr + . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 129
    variable                       shift and go to state 47

state 91

    (50) expr -> - expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NE              reduce using rule 50 (expr -> - expr .)
    =               reduce using rule 50 (expr -> - expr .)
    GE              reduce using rule 50 (expr -> - expr .)
    GT              reduce using rule 50 (expr -> - expr .)
    LE              reduce using rule 50 (expr -> - expr .)
    LT              reduce using rule 50 (expr -> - expr .)
    %               reduce using rule 50 (expr -> - expr .)
    ^               reduce using rule 50 (expr -> - expr .)
    /               reduce using rule 50 (expr -> - expr .)
    *               reduce using rule 50 (expr -> - expr .)
    -               reduce using rule 50 (expr -> - expr .)
    +               reduce using rule 50 (expr -> - expr .)
    ;               reduce using rule 50 (expr -> - expr .)
    ,               reduce using rule 50 (expr -> - expr .)
    NEWLINE         reduce using rule 50 (expr -> - expr .)
    )               reduce using rule 50 (expr -> - expr .)
    TO              reduce using rule 50 (expr -> - expr .)
    THEN            reduce using rule 50 (expr -> - expr .)
    STEP            reduce using rule 50 (expr -> - expr .)


state 92

    (51) expr -> ( expr . )
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    )               shift and go to state 130
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 93

    (52) expr -> FNAME ( . exprlist )
    (65) exprlist -> . exprlist , expr
    (66) exprlist -> . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    exprlist                       shift and go to state 131
    expr                           shift and go to state 132
    variable                       shift and go to state 47

state 94

    (53) expr -> BLTIN ( . exprlist )
    (54) expr -> BLTIN ( . )
    (65) exprlist -> . exprlist , expr
    (66) exprlist -> . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    )               shift and go to state 134
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    exprlist                       shift and go to state 133
    expr                           shift and go to state 132
    variable                       shift and go to state 47

state 95

    (73) variable -> IDENT ( . expr , expr )
    (74) variable -> IDENT ( . expr )
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 135
    variable                       shift and go to state 47

state 96

    (31) command -> PRINT plist optend .
    NEWLINE         reduce using rule 31 (command -> PRINT plist optend .)


state 97

    (88) plist -> plist sep . pitem
    (49) optend -> sep .
    (90) pitem -> . expr
    (91) pitem -> . STRING expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    NEWLINE         reduce using rule 49 (optend -> sep .)
    STRING          shift and go to state 57
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    pitem                          shift and go to state 136
    expr                           shift and go to state 56
    variable                       shift and go to state 47

state 98

    (48) optend -> empty .
    NEWLINE         reduce using rule 48 (optend -> empty .)


state 99

    (92) sep -> ; .
    STRING          reduce using rule 92 (sep -> ; .)
    -               reduce using rule 92 (sep -> ; .)
    (               reduce using rule 92 (sep -> ; .)
    FNAME           reduce using rule 92 (sep -> ; .)
    BLTIN           reduce using rule 92 (sep -> ; .)
    FLOAT           reduce using rule 92 (sep -> ; .)
    INTEGER         reduce using rule 92 (sep -> ; .)
    IDENT           reduce using rule 92 (sep -> ; .)
    NEWLINE         reduce using rule 92 (sep -> ; .)


state 100

    (93) sep -> , .
    STRING          reduce using rule 93 (sep -> , .)
    -               reduce using rule 93 (sep -> , .)
    (               reduce using rule 93 (sep -> , .)
    FNAME           reduce using rule 93 (sep -> , .)
    BLTIN           reduce using rule 93 (sep -> , .)
    FLOAT           reduce using rule 93 (sep -> , .)
    INTEGER         reduce using rule 93 (sep -> , .)
    IDENT           reduce using rule 93 (sep -> , .)
    NEWLINE         reduce using rule 93 (sep -> , .)


state 101

    (91) pitem -> STRING expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    ;               reduce using rule 91 (pitem -> STRING expr .)
    ,               reduce using rule 91 (pitem -> STRING expr .)
    NEWLINE         reduce using rule 91 (pitem -> STRING expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 102

    (33) command -> INPUT _1_STRING_sep_optional varlist .
    (82) varlist -> varlist . , variable
    NEWLINE         reduce using rule 33 (command -> INPUT _1_STRING_sep_optional varlist .)
    ,               shift and go to state 107


state 103

    (34) _1_STRING_sep_optional -> STRING sep .
    IDENT           reduce using rule 34 (_1_STRING_sep_optional -> STRING sep .)


state 104

    (44) mixedlist -> mixedlist , . mixeditem
    (46) mixeditem -> . STRING
    (47) mixeditem -> . number
    (84) number -> . - FLOAT
    (85) number -> . - INTEGER
    (86) number -> . FLOAT
    (87) number -> . INTEGER
    STRING          shift and go to state 64
    -               shift and go to state 66
    FLOAT           shift and go to state 67
    INTEGER         shift and go to state 68

    mixeditem                      shift and go to state 137
    number                         shift and go to state 65

state 105

    (84) number -> - FLOAT .
    ,               reduce using rule 84 (number -> - FLOAT .)
    NEWLINE         reduce using rule 84 (number -> - FLOAT .)


state 106

    (85) number -> - INTEGER .
    ,               reduce using rule 85 (number -> - INTEGER .)
    NEWLINE         reduce using rule 85 (number -> - INTEGER .)


state 107

    (82) varlist -> varlist , . variable
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    IDENT           shift and go to state 50

    variable                       shift and go to state 138

state 108

    (41) command -> LET variable = . error
    (42) command -> LET variable = . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    error           shift and go to state 139
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    variable                       shift and go to state 47
    expr                           shift and go to state 140

state 109

    (80) dimlist -> dimlist , dimitem .
    ,               reduce using rule 80 (dimlist -> dimlist , dimitem .)
    NEWLINE         reduce using rule 80 (dimlist -> dimlist , dimitem .)


state 110

    (78) dimitem -> IDENT ( INTEGER . , INTEGER )
    (79) dimitem -> IDENT ( INTEGER . )
    ,               shift and go to state 141
    )               shift and go to state 142


state 111

    (13) command -> DEF FNAME ( error . ) = expr
    )               shift and go to state 143


state 112

    (14) command -> DEF FNAME ( IDENT . ) = error
    (15) command -> DEF FNAME ( IDENT . ) = expr
    )               shift and go to state 144


state 113

    (21) command -> FOR IDENT = expr . TO error optstep
    (23) command -> FOR IDENT = expr . TO expr optstep
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    TO              shift and go to state 145
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 114

    (22) command -> FOR IDENT = error . TO expr optstep
    TO              shift and go to state 146


state 115

    (24) command -> IF error THEN INTEGER .
    NEWLINE         reduce using rule 24 (command -> IF error THEN INTEGER .)


state 116

    (25) command -> IF relexpr THEN error .
    NEWLINE         reduce using rule 25 (command -> IF relexpr THEN error .)


state 117

    (26) command -> IF relexpr THEN INTEGER .
    NEWLINE         reduce using rule 26 (command -> IF relexpr THEN INTEGER .)


state 118

    (67) relexpr -> expr NE expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    THEN            reduce using rule 67 (relexpr -> expr NE expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 119

    (68) relexpr -> expr = expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    THEN            reduce using rule 68 (relexpr -> expr = expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 120

    (69) relexpr -> expr GE expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    THEN            reduce using rule 69 (relexpr -> expr GE expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 121

    (70) relexpr -> expr GT expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    THEN            reduce using rule 70 (relexpr -> expr GT expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 122

    (71) relexpr -> expr LE expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    THEN            reduce using rule 71 (relexpr -> expr LE expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 123

    (72) relexpr -> expr LT expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    THEN            reduce using rule 72 (relexpr -> expr LT expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 124

    (59) expr -> expr % expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NE              reduce using rule 59 (expr -> expr % expr .)
    =               reduce using rule 59 (expr -> expr % expr .)
    GE              reduce using rule 59 (expr -> expr % expr .)
    GT              reduce using rule 59 (expr -> expr % expr .)
    LE              reduce using rule 59 (expr -> expr % expr .)
    LT              reduce using rule 59 (expr -> expr % expr .)
    %               reduce using rule 59 (expr -> expr % expr .)
    ^               reduce using rule 59 (expr -> expr % expr .)
    /               reduce using rule 59 (expr -> expr % expr .)
    *               reduce using rule 59 (expr -> expr % expr .)
    -               reduce using rule 59 (expr -> expr % expr .)
    +               reduce using rule 59 (expr -> expr % expr .)
    ;               reduce using rule 59 (expr -> expr % expr .)
    ,               reduce using rule 59 (expr -> expr % expr .)
    NEWLINE         reduce using rule 59 (expr -> expr % expr .)
    )               reduce using rule 59 (expr -> expr % expr .)
    TO              reduce using rule 59 (expr -> expr % expr .)
    THEN            reduce using rule 59 (expr -> expr % expr .)
    STEP            reduce using rule 59 (expr -> expr % expr .)


state 125

    (60) expr -> expr ^ expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NE              reduce using rule 60 (expr -> expr ^ expr .)
    =               reduce using rule 60 (expr -> expr ^ expr .)
    GE              reduce using rule 60 (expr -> expr ^ expr .)
    GT              reduce using rule 60 (expr -> expr ^ expr .)
    LE              reduce using rule 60 (expr -> expr ^ expr .)
    LT              reduce using rule 60 (expr -> expr ^ expr .)
    ^               reduce using rule 60 (expr -> expr ^ expr .)
    /               reduce using rule 60 (expr -> expr ^ expr .)
    *               reduce using rule 60 (expr -> expr ^ expr .)
    -               reduce using rule 60 (expr -> expr ^ expr .)
    +               reduce using rule 60 (expr -> expr ^ expr .)
    ;               reduce using rule 60 (expr -> expr ^ expr .)
    ,               reduce using rule 60 (expr -> expr ^ expr .)
    NEWLINE         reduce using rule 60 (expr -> expr ^ expr .)
    )               reduce using rule 60 (expr -> expr ^ expr .)
    TO              reduce using rule 60 (expr -> expr ^ expr .)
    THEN            reduce using rule 60 (expr -> expr ^ expr .)
    STEP            reduce using rule 60 (expr -> expr ^ expr .)
    %               shift and go to state 85


state 126

    (61) expr -> expr / expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NE              reduce using rule 61 (expr -> expr / expr .)
    =               reduce using rule 61 (expr -> expr / expr .)
    GE              reduce using rule 61 (expr -> expr / expr .)
    GT              reduce using rule 61 (expr -> expr / expr .)
    LE              reduce using rule 61 (expr -> expr / expr .)
    LT              reduce using rule 61 (expr -> expr / expr .)
    /               reduce using rule 61 (expr -> expr / expr .)
    *               reduce using rule 61 (expr -> expr / expr .)
    -               reduce using rule 61 (expr -> expr / expr .)
    +               reduce using rule 61 (expr -> expr / expr .)
    ;               reduce using rule 61 (expr -> expr / expr .)
    ,               reduce using rule 61 (expr -> expr / expr .)
    NEWLINE         reduce using rule 61 (expr -> expr / expr .)
    )               reduce using rule 61 (expr -> expr / expr .)
    TO              reduce using rule 61 (expr -> expr / expr .)
    THEN            reduce using rule 61 (expr -> expr / expr .)
    STEP            reduce using rule 61 (expr -> expr / expr .)
    %               shift and go to state 85
    ^               shift and go to state 86


state 127

    (62) expr -> expr * expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NE              reduce using rule 62 (expr -> expr * expr .)
    =               reduce using rule 62 (expr -> expr * expr .)
    GE              reduce using rule 62 (expr -> expr * expr .)
    GT              reduce using rule 62 (expr -> expr * expr .)
    LE              reduce using rule 62 (expr -> expr * expr .)
    LT              reduce using rule 62 (expr -> expr * expr .)
    /               reduce using rule 62 (expr -> expr * expr .)
    *               reduce using rule 62 (expr -> expr * expr .)
    -               reduce using rule 62 (expr -> expr * expr .)
    +               reduce using rule 62 (expr -> expr * expr .)
    ;               reduce using rule 62 (expr -> expr * expr .)
    ,               reduce using rule 62 (expr -> expr * expr .)
    NEWLINE         reduce using rule 62 (expr -> expr * expr .)
    )               reduce using rule 62 (expr -> expr * expr .)
    TO              reduce using rule 62 (expr -> expr * expr .)
    THEN            reduce using rule 62 (expr -> expr * expr .)
    STEP            reduce using rule 62 (expr -> expr * expr .)
    %               shift and go to state 85
    ^               shift and go to state 86


state 128

    (63) expr -> expr - expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NE              reduce using rule 63 (expr -> expr - expr .)
    =               reduce using rule 63 (expr -> expr - expr .)
    GE              reduce using rule 63 (expr -> expr - expr .)
    GT              reduce using rule 63 (expr -> expr - expr .)
    LE              reduce using rule 63 (expr -> expr - expr .)
    LT              reduce using rule 63 (expr -> expr - expr .)
    -               reduce using rule 63 (expr -> expr - expr .)
    +               reduce using rule 63 (expr -> expr - expr .)
    ;               reduce using rule 63 (expr -> expr - expr .)
    ,               reduce using rule 63 (expr -> expr - expr .)
    NEWLINE         reduce using rule 63 (expr -> expr - expr .)
    )               reduce using rule 63 (expr -> expr - expr .)
    TO              reduce using rule 63 (expr -> expr - expr .)
    THEN            reduce using rule 63 (expr -> expr - expr .)
    STEP            reduce using rule 63 (expr -> expr - expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88


state 129

    (64) expr -> expr + expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NE              reduce using rule 64 (expr -> expr + expr .)
    =               reduce using rule 64 (expr -> expr + expr .)
    GE              reduce using rule 64 (expr -> expr + expr .)
    GT              reduce using rule 64 (expr -> expr + expr .)
    LE              reduce using rule 64 (expr -> expr + expr .)
    LT              reduce using rule 64 (expr -> expr + expr .)
    -               reduce using rule 64 (expr -> expr + expr .)
    +               reduce using rule 64 (expr -> expr + expr .)
    ;               reduce using rule 64 (expr -> expr + expr .)
    ,               reduce using rule 64 (expr -> expr + expr .)
    NEWLINE         reduce using rule 64 (expr -> expr + expr .)
    )               reduce using rule 64 (expr -> expr + expr .)
    TO              reduce using rule 64 (expr -> expr + expr .)
    THEN            reduce using rule 64 (expr -> expr + expr .)
    STEP            reduce using rule 64 (expr -> expr + expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88


state 130

    (51) expr -> ( expr ) .
    NE              reduce using rule 51 (expr -> ( expr ) .)
    =               reduce using rule 51 (expr -> ( expr ) .)
    GE              reduce using rule 51 (expr -> ( expr ) .)
    GT              reduce using rule 51 (expr -> ( expr ) .)
    LE              reduce using rule 51 (expr -> ( expr ) .)
    LT              reduce using rule 51 (expr -> ( expr ) .)
    %               reduce using rule 51 (expr -> ( expr ) .)
    ^               reduce using rule 51 (expr -> ( expr ) .)
    /               reduce using rule 51 (expr -> ( expr ) .)
    *               reduce using rule 51 (expr -> ( expr ) .)
    -               reduce using rule 51 (expr -> ( expr ) .)
    +               reduce using rule 51 (expr -> ( expr ) .)
    ;               reduce using rule 51 (expr -> ( expr ) .)
    ,               reduce using rule 51 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 51 (expr -> ( expr ) .)
    )               reduce using rule 51 (expr -> ( expr ) .)
    TO              reduce using rule 51 (expr -> ( expr ) .)
    THEN            reduce using rule 51 (expr -> ( expr ) .)
    STEP            reduce using rule 51 (expr -> ( expr ) .)


state 131

    (52) expr -> FNAME ( exprlist . )
    (65) exprlist -> exprlist . , expr
    )               shift and go to state 147
    ,               shift and go to state 148


state 132

    (66) exprlist -> expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    )               reduce using rule 66 (exprlist -> expr .)
    ,               reduce using rule 66 (exprlist -> expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 133

    (53) expr -> BLTIN ( exprlist . )
    (65) exprlist -> exprlist . , expr
    )               shift and go to state 149
    ,               shift and go to state 148


state 134

    (54) expr -> BLTIN ( ) .
    NE              reduce using rule 54 (expr -> BLTIN ( ) .)
    =               reduce using rule 54 (expr -> BLTIN ( ) .)
    GE              reduce using rule 54 (expr -> BLTIN ( ) .)
    GT              reduce using rule 54 (expr -> BLTIN ( ) .)
    LE              reduce using rule 54 (expr -> BLTIN ( ) .)
    LT              reduce using rule 54 (expr -> BLTIN ( ) .)
    %               reduce using rule 54 (expr -> BLTIN ( ) .)
    ^               reduce using rule 54 (expr -> BLTIN ( ) .)
    /               reduce using rule 54 (expr -> BLTIN ( ) .)
    *               reduce using rule 54 (expr -> BLTIN ( ) .)
    -               reduce using rule 54 (expr -> BLTIN ( ) .)
    +               reduce using rule 54 (expr -> BLTIN ( ) .)
    ;               reduce using rule 54 (expr -> BLTIN ( ) .)
    ,               reduce using rule 54 (expr -> BLTIN ( ) .)
    NEWLINE         reduce using rule 54 (expr -> BLTIN ( ) .)
    )               reduce using rule 54 (expr -> BLTIN ( ) .)
    TO              reduce using rule 54 (expr -> BLTIN ( ) .)
    THEN            reduce using rule 54 (expr -> BLTIN ( ) .)
    STEP            reduce using rule 54 (expr -> BLTIN ( ) .)


state 135

    (73) variable -> IDENT ( expr . , expr )
    (74) variable -> IDENT ( expr . )
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    ,               shift and go to state 150
    )               shift and go to state 151
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 136

    (88) plist -> plist sep pitem .
    ;               reduce using rule 88 (plist -> plist sep pitem .)
    ,               reduce using rule 88 (plist -> plist sep pitem .)
    NEWLINE         reduce using rule 88 (plist -> plist sep pitem .)


state 137

    (44) mixedlist -> mixedlist , mixeditem .
    ,               reduce using rule 44 (mixedlist -> mixedlist , mixeditem .)
    NEWLINE         reduce using rule 44 (mixedlist -> mixedlist , mixeditem .)


state 138

    (82) varlist -> varlist , variable .
    ,               reduce using rule 82 (varlist -> varlist , variable .)
    NEWLINE         reduce using rule 82 (varlist -> varlist , variable .)


state 139

    (41) command -> LET variable = error .
    NEWLINE         reduce using rule 41 (command -> LET variable = error .)


state 140

    (42) command -> LET variable = expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NEWLINE         reduce using rule 42 (command -> LET variable = expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 141

    (78) dimitem -> IDENT ( INTEGER , . INTEGER )
    INTEGER         shift and go to state 152


state 142

    (79) dimitem -> IDENT ( INTEGER ) .
    ,               reduce using rule 79 (dimitem -> IDENT ( INTEGER ) .)
    NEWLINE         reduce using rule 79 (dimitem -> IDENT ( INTEGER ) .)


state 143

    (13) command -> DEF FNAME ( error ) . = expr
    =               shift and go to state 153


state 144

    (14) command -> DEF FNAME ( IDENT ) . = error
    (15) command -> DEF FNAME ( IDENT ) . = expr
    =               shift and go to state 154


state 145

    (21) command -> FOR IDENT = expr TO . error optstep
    (23) command -> FOR IDENT = expr TO . expr optstep
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    error           shift and go to state 156
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 155
    variable                       shift and go to state 47

state 146

    (22) command -> FOR IDENT = error TO . expr optstep
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 157
    variable                       shift and go to state 47

state 147

    (52) expr -> FNAME ( exprlist ) .
    NE              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    =               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    GE              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    GT              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    LE              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    LT              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    %               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    ^               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    /               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    *               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    -               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    +               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    ;               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    ,               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    NEWLINE         reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    )               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    TO              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    THEN            reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    STEP            reduce using rule 52 (expr -> FNAME ( exprlist ) .)


state 148

    (65) exprlist -> exprlist , . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 158
    variable                       shift and go to state 47

state 149

    (53) expr -> BLTIN ( exprlist ) .
    NE              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    =               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    GE              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    GT              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    LE              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    LT              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    %               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    ^               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    /               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    *               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    -               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    +               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    ;               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    ,               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    NEWLINE         reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    )               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    TO              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    THEN            reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    STEP            reduce using rule 53 (expr -> BLTIN ( exprlist ) .)


state 150

    (73) variable -> IDENT ( expr , . expr )
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 159
    variable                       shift and go to state 47

state 151

    (74) variable -> IDENT ( expr ) .
    NE              reduce using rule 74 (variable -> IDENT ( expr ) .)
    =               reduce using rule 74 (variable -> IDENT ( expr ) .)
    GE              reduce using rule 74 (variable -> IDENT ( expr ) .)
    GT              reduce using rule 74 (variable -> IDENT ( expr ) .)
    LE              reduce using rule 74 (variable -> IDENT ( expr ) .)
    LT              reduce using rule 74 (variable -> IDENT ( expr ) .)
    %               reduce using rule 74 (variable -> IDENT ( expr ) .)
    ^               reduce using rule 74 (variable -> IDENT ( expr ) .)
    /               reduce using rule 74 (variable -> IDENT ( expr ) .)
    *               reduce using rule 74 (variable -> IDENT ( expr ) .)
    -               reduce using rule 74 (variable -> IDENT ( expr ) .)
    +               reduce using rule 74 (variable -> IDENT ( expr ) .)
    ;               reduce using rule 74 (variable -> IDENT ( expr ) .)
    ,               reduce using rule 74 (variable -> IDENT ( expr ) .)
    NEWLINE         reduce using rule 74 (variable -> IDENT ( expr ) .)
    )               reduce using rule 74 (variable -> IDENT ( expr ) .)
    TO              reduce using rule 74 (variable -> IDENT ( expr ) .)
    THEN            reduce using rule 74 (variable -> IDENT ( expr ) .)
    STEP            reduce using rule 74 (variable -> IDENT ( expr ) .)


state 152

    (78) dimitem -> IDENT ( INTEGER , INTEGER . )
    )               shift and go to state 160


state 153

    (13) command -> DEF FNAME ( error ) = . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 161
    variable                       shift and go to state 47

state 154

    (14) command -> DEF FNAME ( IDENT ) = . error
    (15) command -> DEF FNAME ( IDENT ) = . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    error           shift and go to state 162
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 163
    variable                       shift and go to state 47

state 155

    (23) command -> FOR IDENT = expr TO expr . optstep
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (76) optstep -> . empty
    (77) optstep -> . STEP expr
    (94) empty -> .
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90
    STEP            shift and go to state 166
    NEWLINE         reduce using rule 94 (empty -> .)

    optstep                        shift and go to state 164
    empty                          shift and go to state 165

state 156

    (21) command -> FOR IDENT = expr TO error . optstep
    (76) optstep -> . empty
    (77) optstep -> . STEP expr
    (94) empty -> .
    STEP            shift and go to state 166
    NEWLINE         reduce using rule 94 (empty -> .)

    optstep                        shift and go to state 167
    empty                          shift and go to state 165

state 157

    (22) command -> FOR IDENT = error TO expr . optstep
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    (76) optstep -> . empty
    (77) optstep -> . STEP expr
    (94) empty -> .
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90
    STEP            shift and go to state 166
    NEWLINE         reduce using rule 94 (empty -> .)

    optstep                        shift and go to state 168
    empty                          shift and go to state 165

state 158

    (65) exprlist -> exprlist , expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    )               reduce using rule 65 (exprlist -> exprlist , expr .)
    ,               reduce using rule 65 (exprlist -> exprlist , expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 159

    (73) variable -> IDENT ( expr , expr . )
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    )               shift and go to state 169
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 160

    (78) dimitem -> IDENT ( INTEGER , INTEGER ) .
    ,               reduce using rule 78 (dimitem -> IDENT ( INTEGER , INTEGER ) .)
    NEWLINE         reduce using rule 78 (dimitem -> IDENT ( INTEGER , INTEGER ) .)


state 161

    (13) command -> DEF FNAME ( error ) = expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NEWLINE         reduce using rule 13 (command -> DEF FNAME ( error ) = expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 162

    (14) command -> DEF FNAME ( IDENT ) = error .
    NEWLINE         reduce using rule 14 (command -> DEF FNAME ( IDENT ) = error .)


state 163

    (15) command -> DEF FNAME ( IDENT ) = expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NEWLINE         reduce using rule 15 (command -> DEF FNAME ( IDENT ) = expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


state 164

    (23) command -> FOR IDENT = expr TO expr optstep .
    NEWLINE         reduce using rule 23 (command -> FOR IDENT = expr TO expr optstep .)


state 165

    (76) optstep -> empty .
    NEWLINE         reduce using rule 76 (optstep -> empty .)


state 166

    (77) optstep -> STEP . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr % expr
    (60) expr -> . expr ^ expr
    (61) expr -> . expr / expr
    (62) expr -> . expr * expr
    (63) expr -> . expr - expr
    (64) expr -> . expr + expr
    (73) variable -> . IDENT ( expr , expr )
    (74) variable -> . IDENT ( expr )
    (75) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 170
    variable                       shift and go to state 47

state 167

    (21) command -> FOR IDENT = expr TO error optstep .
    NEWLINE         reduce using rule 21 (command -> FOR IDENT = expr TO error optstep .)


state 168

    (22) command -> FOR IDENT = error TO expr optstep .
    NEWLINE         reduce using rule 22 (command -> FOR IDENT = error TO expr optstep .)


state 169

    (73) variable -> IDENT ( expr , expr ) .
    NE              reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    =               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    GE              reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    GT              reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    LE              reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    LT              reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    %               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    ^               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    /               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    *               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    -               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    +               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    ;               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    ,               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    NEWLINE         reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    )               reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    TO              reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    THEN            reduce using rule 73 (variable -> IDENT ( expr , expr ) .)
    STEP            reduce using rule 73 (variable -> IDENT ( expr , expr ) .)


state 170

    (77) optstep -> STEP expr .
    (59) expr -> expr . % expr
    (60) expr -> expr . ^ expr
    (61) expr -> expr . / expr
    (62) expr -> expr . * expr
    (63) expr -> expr . - expr
    (64) expr -> expr . + expr
    NEWLINE         reduce using rule 77 (optstep -> STEP expr .)
    %               shift and go to state 85
    ^               shift and go to state 86
    /               shift and go to state 87
    *               shift and go to state 88
    -               shift and go to state 89
    +               shift and go to state 90


Conflicts:

shift/reduce conflict for NEWLINE in state 9 resolved as shift
shift/reduce conflict for - in state 57 resolved as shift