Grammar:

Rule 0     S' -> program
Rule 1     program -> error
Rule 2     program -> stmt
Rule 3     program -> program stmt
Rule 4     stmt -> NEWLINE
Rule 5     stmt -> INTEGER NEWLINE
Rule 6     stmt -> INTEGER error NEWLINE
Rule 7     stmt -> INTEGER command NEWLINE
Rule 8     command -> DIM error
Rule 9     command -> DIM dimlist
Rule 10    command -> RETURN
Rule 11    command -> GOSUB error
Rule 12    command -> GOSUB INTEGER
Rule 13    command -> DEF FNAME ( error ) = expr
Rule 14    command -> DEF FNAME ( IDENT ) = error
Rule 15    command -> DEF FNAME ( IDENT ) = expr
Rule 16    command -> STOP
Rule 17    command -> REM
Rule 18    command -> END
Rule 19    command -> NEXT error
Rule 20    command -> NEXT IDENT
Rule 21    command -> FOR IDENT = expr TO error optstep
Rule 22    command -> FOR IDENT = error TO expr optstep
Rule 23    command -> FOR IDENT = expr TO expr optstep
Rule 24    command -> IF error THEN INTEGER
Rule 25    command -> IF relexpr THEN error
Rule 26    command -> IF relexpr THEN INTEGER
Rule 27    command -> GOTO error
Rule 28    command -> GOTO INTEGER
Rule 29    command -> PRINT error
Rule 30    command -> PRINT
Rule 31    command -> PRINT plist optend
Rule 32    command -> INPUT error
Rule 33    command -> INPUT _1_STRING_0x2c_optional varlist
Rule 34    _1_STRING_0x2c_optional -> STRING ,
Rule 35    _1_STRING_0x2c_optional -> <empty>
Rule 36    command -> DATA error
Rule 37    command -> DATA numlist
Rule 38    command -> READ error
Rule 39    command -> READ varlist
Rule 40    command -> LET variable = error
Rule 41    command -> LET variable = expr
Rule 42    command -> command
Rule 43    optend -> empty
Rule 44    optend -> sep
Rule 45    expr -> - expr  [precedence=right, level=4]
Rule 46    expr -> ( expr )
Rule 47    expr -> FNAME ( expr )
Rule 48    expr -> BLTIN ( expr )
Rule 49    expr -> BLTIN ( )
Rule 50    expr -> variable
Rule 51    expr -> STRING
Rule 52    expr -> FLOAT
Rule 53    expr -> INTEGER
Rule 54    expr -> expr ^ expr  [precedence=left, level=3]
Rule 55    expr -> expr / expr  [precedence=left, level=2]
Rule 56    expr -> expr * expr  [precedence=left, level=2]
Rule 57    expr -> expr - expr  [precedence=left, level=1]
Rule 58    expr -> expr + expr  [precedence=left, level=1]
Rule 59    relexpr -> expr NE expr
Rule 60    relexpr -> expr = expr
Rule 61    relexpr -> expr GE expr
Rule 62    relexpr -> expr GT expr
Rule 63    relexpr -> expr LE expr
Rule 64    relexpr -> expr LT expr
Rule 65    variable -> IDENT ( expr , expr )
Rule 66    variable -> IDENT ( expr )
Rule 67    variable -> IDENT ( INTEGER , INTEGER )
Rule 68    variable -> IDENT ( INTEGER )
Rule 69    variable -> IDENT
Rule 70    optstep -> empty
Rule 71    optstep -> STEP expr
Rule 72    dimlist -> dimlist , dimitem
Rule 73    dimlist -> dimitem
Rule 74    dimitem -> IDENT ( INTEGER , INTEGER )
Rule 75    dimitem -> IDENT ( INTEGER )
Rule 76    varlist -> varlist , variable
Rule 77    varlist -> variable
Rule 78    numlist -> numlist , number
Rule 79    numlist -> number
Rule 80    number -> - FLOAT  [precedence=right, level=4]
Rule 81    number -> - INTEGER  [precedence=right, level=4]
Rule 82    number -> FLOAT
Rule 83    number -> INTEGER
Rule 84    plist -> plist sep pitem
Rule 85    plist -> pitem
Rule 86    pitem -> expr
Rule 87    pitem -> STRING expr
Rule 88    sep -> ;
Rule 89    sep -> ,
Rule 90    empty -> <empty>

Terminals, with rules where they appear:

(                    : 13 14 15 46 47 48 49 65 66 67 68 74 75
)                    : 13 14 15 46 47 48 49 65 66 67 68 74 75
*                    : 56
+                    : 58
,                    : 34 65 67 72 74 76 78 89
-                    : 45 57 80 81
/                    : 55
;                    : 88
=                    : 13 14 15 21 22 23 40 41 60
BLTIN                : 48 49
DATA                 : 36 37
DEF                  : 13 14 15
DIM                  : 8 9
END                  : 18
FLOAT                : 52 80 82
FNAME                : 13 14 15 47
FOR                  : 21 22 23
GE                   : 61
GOSUB                : 11 12
GOTO                 : 27 28
GT                   : 62
IDENT                : 14 15 20 21 22 23 65 66 67 68 69 74 75
IF                   : 24 25 26
INPUT                : 32 33
INTEGER              : 5 6 7 12 24 26 28 53 67 67 68 74 74 75 81 83
LE                   : 63
LET                  : 40 41
LT                   : 64
NE                   : 59
NEWLINE              : 4 5 6 7
NEXT                 : 19 20
PRINT                : 29 30 31
READ                 : 38 39
REM                  : 17
RETURN               : 10
STEP                 : 71
STOP                 : 16
STRING               : 34 51 87
THEN                 : 24 25 26
TO                   : 21 22 23
^                    : 54
error                : 1 6 8 11 13 14 19 21 22 24 25 27 29 32 36 38 40

Nonterminals, with rules where they appear:

_1_STRING_0x2c_optional : 33
command              : 7 42
dimitem              : 72 73
dimlist              : 9 72
empty                : 43 70
expr                 : 13 15 21 22 23 23 41 45 46 47 48 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 64 65 65 66 71 86 87
number               : 78 79
numlist              : 37 78
optend               : 31
optstep              : 21 22 23
pitem                : 84 85
plist                : 31 84
program              : 3 0
relexpr              : 25 26
sep                  : 44 84
stmt                 : 2 3
variable             : 40 41 50 76 77
varlist              : 33 39 76


state 0

    (0) S' -> . program
    (1) program -> . error
    (2) program -> . stmt
    (3) program -> . program stmt
    (4) stmt -> . NEWLINE
    (5) stmt -> . INTEGER NEWLINE
    (6) stmt -> . INTEGER error NEWLINE
    (7) stmt -> . INTEGER command NEWLINE
    error           shift and go to state 2
    NEWLINE         shift and go to state 4
    INTEGER         shift and go to state 5

    program                        shift and go to state 1
    stmt                           shift and go to state 3

state 1

    (0) S' -> program .
    (3) program -> program . stmt
    (4) stmt -> . NEWLINE
    (5) stmt -> . INTEGER NEWLINE
    (6) stmt -> . INTEGER error NEWLINE
    (7) stmt -> . INTEGER command NEWLINE
    NEWLINE         shift and go to state 4
    INTEGER         shift and go to state 5

    stmt                           shift and go to state 6

state 2

    (1) program -> error .
    NEWLINE         reduce using rule 1 (program -> error .)
    INTEGER         reduce using rule 1 (program -> error .)
    $end            reduce using rule 1 (program -> error .)


state 3

    (2) program -> stmt .
    NEWLINE         reduce using rule 2 (program -> stmt .)
    INTEGER         reduce using rule 2 (program -> stmt .)
    $end            reduce using rule 2 (program -> stmt .)


state 4

    (4) stmt -> NEWLINE .
    NEWLINE         reduce using rule 4 (stmt -> NEWLINE .)
    INTEGER         reduce using rule 4 (stmt -> NEWLINE .)
    $end            reduce using rule 4 (stmt -> NEWLINE .)


state 5

    (5) stmt -> INTEGER . NEWLINE
    (6) stmt -> INTEGER . error NEWLINE
    (7) stmt -> INTEGER . command NEWLINE
    (8) command -> . DIM error
    (9) command -> . DIM dimlist
    (10) command -> . RETURN
    (11) command -> . GOSUB error
    (12) command -> . GOSUB INTEGER
    (13) command -> . DEF FNAME ( error ) = expr
    (14) command -> . DEF FNAME ( IDENT ) = error
    (15) command -> . DEF FNAME ( IDENT ) = expr
    (16) command -> . STOP
    (17) command -> . REM
    (18) command -> . END
    (19) command -> . NEXT error
    (20) command -> . NEXT IDENT
    (21) command -> . FOR IDENT = expr TO error optstep
    (22) command -> . FOR IDENT = error TO expr optstep
    (23) command -> . FOR IDENT = expr TO expr optstep
    (24) command -> . IF error THEN INTEGER
    (25) command -> . IF relexpr THEN error
    (26) command -> . IF relexpr THEN INTEGER
    (27) command -> . GOTO error
    (28) command -> . GOTO INTEGER
    (29) command -> . PRINT error
    (30) command -> . PRINT
    (31) command -> . PRINT plist optend
    (32) command -> . INPUT error
    (33) command -> . INPUT _1_STRING_0x2c_optional varlist
    (36) command -> . DATA error
    (37) command -> . DATA numlist
    (38) command -> . READ error
    (39) command -> . READ varlist
    (40) command -> . LET variable = error
    (41) command -> . LET variable = expr
    (42) command -> . command
    NEWLINE         shift and go to state 7
    error           shift and go to state 8
    DIM             shift and go to state 10
    RETURN          shift and go to state 11
    GOSUB           shift and go to state 12
    DEF             shift and go to state 13
    STOP            shift and go to state 14
    REM             shift and go to state 15
    END             shift and go to state 16
    NEXT            shift and go to state 17
    FOR             shift and go to state 18
    IF              shift and go to state 19
    GOTO            shift and go to state 20
    PRINT           shift and go to state 21
    INPUT           shift and go to state 22
    DATA            shift and go to state 23
    READ            shift and go to state 24
    LET             shift and go to state 25

    command                        shift and go to state 9

state 6

    (3) program -> program stmt .
    NEWLINE         reduce using rule 3 (program -> program stmt .)
    INTEGER         reduce using rule 3 (program -> program stmt .)
    $end            reduce using rule 3 (program -> program stmt .)


state 7

    (5) stmt -> INTEGER NEWLINE .
    NEWLINE         reduce using rule 5 (stmt -> INTEGER NEWLINE .)
    INTEGER         reduce using rule 5 (stmt -> INTEGER NEWLINE .)
    $end            reduce using rule 5 (stmt -> INTEGER NEWLINE .)


state 8

    (6) stmt -> INTEGER error . NEWLINE
    NEWLINE         shift and go to state 26


state 9

    (7) stmt -> INTEGER command . NEWLINE
    (42) command -> command .
  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 27


state 10

    (8) command -> DIM . error
    (9) command -> DIM . dimlist
    (72) dimlist -> . dimlist , dimitem
    (73) dimlist -> . dimitem
    (74) dimitem -> . IDENT ( INTEGER , INTEGER )
    (75) dimitem -> . IDENT ( INTEGER )
    error           shift and go to state 28
    IDENT           shift and go to state 31

    dimlist                        shift and go to state 29
    dimitem                        shift and go to state 30

state 11

    (10) command -> RETURN .
    NEWLINE         reduce using rule 10 (command -> RETURN .)


state 12

    (11) command -> GOSUB . error
    (12) command -> GOSUB . INTEGER
    error           shift and go to state 32
    INTEGER         shift and go to state 33


state 13

    (13) command -> DEF . FNAME ( error ) = expr
    (14) command -> DEF . FNAME ( IDENT ) = error
    (15) command -> DEF . FNAME ( IDENT ) = expr
    FNAME           shift and go to state 34


state 14

    (16) command -> STOP .
    NEWLINE         reduce using rule 16 (command -> STOP .)


state 15

    (17) command -> REM .
    NEWLINE         reduce using rule 17 (command -> REM .)


state 16

    (18) command -> END .
    NEWLINE         reduce using rule 18 (command -> END .)


state 17

    (19) command -> NEXT . error
    (20) command -> NEXT . IDENT
    error           shift and go to state 35
    IDENT           shift and go to state 36


state 18

    (21) command -> FOR . IDENT = expr TO error optstep
    (22) command -> FOR . IDENT = error TO expr optstep
    (23) command -> FOR . IDENT = expr TO expr optstep
    IDENT           shift and go to state 37


state 19

    (24) command -> IF . error THEN INTEGER
    (25) command -> IF . relexpr THEN error
    (26) command -> IF . relexpr THEN INTEGER
    (59) relexpr -> . expr NE expr
    (60) relexpr -> . expr = expr
    (61) relexpr -> . expr GE expr
    (62) relexpr -> . expr GT expr
    (63) relexpr -> . expr LE expr
    (64) relexpr -> . expr LT expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    error           shift and go to state 38
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    relexpr                        shift and go to state 40
    expr                           shift and go to state 41
    variable                       shift and go to state 46

state 20

    (27) command -> GOTO . error
    (28) command -> GOTO . INTEGER
    error           shift and go to state 50
    INTEGER         shift and go to state 51


state 21

    (29) command -> PRINT . error
    (30) command -> PRINT .
    (31) command -> PRINT . plist optend
    (84) plist -> . plist sep pitem
    (85) plist -> . pitem
    (86) pitem -> . expr
    (87) pitem -> . STRING expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    error           shift and go to state 52
    NEWLINE         reduce using rule 30 (command -> PRINT .)
    STRING          shift and go to state 56
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    plist                          shift and go to state 53
    pitem                          shift and go to state 54
    expr                           shift and go to state 55
    variable                       shift and go to state 46

state 22

    (32) command -> INPUT . error
    (33) command -> INPUT . _1_STRING_0x2c_optional varlist
    (34) _1_STRING_0x2c_optional -> . STRING ,
    (35) _1_STRING_0x2c_optional -> .
    error           shift and go to state 57
    STRING          shift and go to state 59
    IDENT           reduce using rule 35 (_1_STRING_0x2c_optional -> .)

    _1_STRING_0x2c_optional        shift and go to state 58

state 23

    (36) command -> DATA . error
    (37) command -> DATA . numlist
    (78) numlist -> . numlist , number
    (79) numlist -> . number
    (80) number -> . - FLOAT
    (81) number -> . - INTEGER
    (82) number -> . FLOAT
    (83) number -> . INTEGER
    error           shift and go to state 60
    -               shift and go to state 63
    FLOAT           shift and go to state 64
    INTEGER         shift and go to state 65

    numlist                        shift and go to state 61
    number                         shift and go to state 62

state 24

    (38) command -> READ . error
    (39) command -> READ . varlist
    (76) varlist -> . varlist , variable
    (77) varlist -> . variable
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    error           shift and go to state 66
    IDENT           shift and go to state 49

    varlist                        shift and go to state 67
    variable                       shift and go to state 68

state 25

    (40) command -> LET . variable = error
    (41) command -> LET . variable = expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    IDENT           shift and go to state 49

    variable                       shift and go to state 69

state 26

    (6) stmt -> INTEGER error NEWLINE .
    NEWLINE         reduce using rule 6 (stmt -> INTEGER error NEWLINE .)
    INTEGER         reduce using rule 6 (stmt -> INTEGER error NEWLINE .)
    $end            reduce using rule 6 (stmt -> INTEGER error NEWLINE .)


state 27

    (7) stmt -> INTEGER command NEWLINE .
    NEWLINE         reduce using rule 7 (stmt -> INTEGER command NEWLINE .)
    INTEGER         reduce using rule 7 (stmt -> INTEGER command NEWLINE .)
    $end            reduce using rule 7 (stmt -> INTEGER command NEWLINE .)


state 28

    (8) command -> DIM error .
    NEWLINE         reduce using rule 8 (command -> DIM error .)


state 29

    (9) command -> DIM dimlist .
    (72) dimlist -> dimlist . , dimitem
    NEWLINE         reduce using rule 9 (command -> DIM dimlist .)
    ,               shift and go to state 70


state 30

    (73) dimlist -> dimitem .
    ,               reduce using rule 73 (dimlist -> dimitem .)
    NEWLINE         reduce using rule 73 (dimlist -> dimitem .)


state 31

    (74) dimitem -> IDENT . ( INTEGER , INTEGER )
    (75) dimitem -> IDENT . ( INTEGER )
    (               shift and go to state 71


state 32

    (11) command -> GOSUB error .
    NEWLINE         reduce using rule 11 (command -> GOSUB error .)


state 33

    (12) command -> GOSUB INTEGER .
    NEWLINE         reduce using rule 12 (command -> GOSUB INTEGER .)


state 34

    (13) command -> DEF FNAME . ( error ) = expr
    (14) command -> DEF FNAME . ( IDENT ) = error
    (15) command -> DEF FNAME . ( IDENT ) = expr
    (               shift and go to state 72


state 35

    (19) command -> NEXT error .
    NEWLINE         reduce using rule 19 (command -> NEXT error .)


state 36

    (20) command -> NEXT IDENT .
    NEWLINE         reduce using rule 20 (command -> NEXT IDENT .)


state 37

    (21) command -> FOR IDENT . = expr TO error optstep
    (22) command -> FOR IDENT . = error TO expr optstep
    (23) command -> FOR IDENT . = expr TO expr optstep
    =               shift and go to state 73


state 38

    (24) command -> IF error . THEN INTEGER
    THEN            shift and go to state 74


state 39

    (53) expr -> INTEGER .
    NE              reduce using rule 53 (expr -> INTEGER .)
    =               reduce using rule 53 (expr -> INTEGER .)
    GE              reduce using rule 53 (expr -> INTEGER .)
    GT              reduce using rule 53 (expr -> INTEGER .)
    LE              reduce using rule 53 (expr -> INTEGER .)
    LT              reduce using rule 53 (expr -> INTEGER .)
    ^               reduce using rule 53 (expr -> INTEGER .)
    /               reduce using rule 53 (expr -> INTEGER .)
    *               reduce using rule 53 (expr -> INTEGER .)
    -               reduce using rule 53 (expr -> INTEGER .)
    +               reduce using rule 53 (expr -> INTEGER .)
    ;               reduce using rule 53 (expr -> INTEGER .)
    ,               reduce using rule 53 (expr -> INTEGER .)
    NEWLINE         reduce using rule 53 (expr -> INTEGER .)
    )               reduce using rule 53 (expr -> INTEGER .)
    TO              reduce using rule 53 (expr -> INTEGER .)
    THEN            reduce using rule 53 (expr -> INTEGER .)
    STEP            reduce using rule 53 (expr -> INTEGER .)


state 40

    (25) command -> IF relexpr . THEN error
    (26) command -> IF relexpr . THEN INTEGER
    THEN            shift and go to state 75


state 41

    (59) relexpr -> expr . NE expr
    (60) relexpr -> expr . = expr
    (61) relexpr -> expr . GE expr
    (62) relexpr -> expr . GT expr
    (63) relexpr -> expr . LE expr
    (64) relexpr -> expr . LT expr
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NE              shift and go to state 76
    =               shift and go to state 77
    GE              shift and go to state 78
    GT              shift and go to state 79
    LE              shift and go to state 80
    LT              shift and go to state 81
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 42

    (45) expr -> - . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 87
    variable                       shift and go to state 46

state 43

    (46) expr -> ( . expr )
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 88
    variable                       shift and go to state 46

state 44

    (47) expr -> FNAME . ( expr )
    (               shift and go to state 89


state 45

    (48) expr -> BLTIN . ( expr )
    (49) expr -> BLTIN . ( )
    (               shift and go to state 90


state 46

    (50) expr -> variable .
    NE              reduce using rule 50 (expr -> variable .)
    =               reduce using rule 50 (expr -> variable .)
    GE              reduce using rule 50 (expr -> variable .)
    GT              reduce using rule 50 (expr -> variable .)
    LE              reduce using rule 50 (expr -> variable .)
    LT              reduce using rule 50 (expr -> variable .)
    ^               reduce using rule 50 (expr -> variable .)
    /               reduce using rule 50 (expr -> variable .)
    *               reduce using rule 50 (expr -> variable .)
    -               reduce using rule 50 (expr -> variable .)
    +               reduce using rule 50 (expr -> variable .)
    ;               reduce using rule 50 (expr -> variable .)
    ,               reduce using rule 50 (expr -> variable .)
    NEWLINE         reduce using rule 50 (expr -> variable .)
    )               reduce using rule 50 (expr -> variable .)
    TO              reduce using rule 50 (expr -> variable .)
    THEN            reduce using rule 50 (expr -> variable .)
    STEP            reduce using rule 50 (expr -> variable .)


state 47

    (51) expr -> STRING .
    NE              reduce using rule 51 (expr -> STRING .)
    =               reduce using rule 51 (expr -> STRING .)
    GE              reduce using rule 51 (expr -> STRING .)
    GT              reduce using rule 51 (expr -> STRING .)
    LE              reduce using rule 51 (expr -> STRING .)
    LT              reduce using rule 51 (expr -> STRING .)
    ^               reduce using rule 51 (expr -> STRING .)
    /               reduce using rule 51 (expr -> STRING .)
    *               reduce using rule 51 (expr -> STRING .)
    -               reduce using rule 51 (expr -> STRING .)
    +               reduce using rule 51 (expr -> STRING .)
    ;               reduce using rule 51 (expr -> STRING .)
    ,               reduce using rule 51 (expr -> STRING .)
    NEWLINE         reduce using rule 51 (expr -> STRING .)
    )               reduce using rule 51 (expr -> STRING .)
    TO              reduce using rule 51 (expr -> STRING .)
    THEN            reduce using rule 51 (expr -> STRING .)
    STEP            reduce using rule 51 (expr -> STRING .)


state 48

    (52) expr -> FLOAT .
    NE              reduce using rule 52 (expr -> FLOAT .)
    =               reduce using rule 52 (expr -> FLOAT .)
    GE              reduce using rule 52 (expr -> FLOAT .)
    GT              reduce using rule 52 (expr -> FLOAT .)
    LE              reduce using rule 52 (expr -> FLOAT .)
    LT              reduce using rule 52 (expr -> FLOAT .)
    ^               reduce using rule 52 (expr -> FLOAT .)
    /               reduce using rule 52 (expr -> FLOAT .)
    *               reduce using rule 52 (expr -> FLOAT .)
    -               reduce using rule 52 (expr -> FLOAT .)
    +               reduce using rule 52 (expr -> FLOAT .)
    ;               reduce using rule 52 (expr -> FLOAT .)
    ,               reduce using rule 52 (expr -> FLOAT .)
    NEWLINE         reduce using rule 52 (expr -> FLOAT .)
    )               reduce using rule 52 (expr -> FLOAT .)
    TO              reduce using rule 52 (expr -> FLOAT .)
    THEN            reduce using rule 52 (expr -> FLOAT .)
    STEP            reduce using rule 52 (expr -> FLOAT .)


state 49

    (65) variable -> IDENT . ( expr , expr )
    (66) variable -> IDENT . ( expr )
    (67) variable -> IDENT . ( INTEGER , INTEGER )
    (68) variable -> IDENT . ( INTEGER )
    (69) variable -> IDENT .
    (               shift and go to state 91
    NE              reduce using rule 69 (variable -> IDENT .)
    =               reduce using rule 69 (variable -> IDENT .)
    GE              reduce using rule 69 (variable -> IDENT .)
    GT              reduce using rule 69 (variable -> IDENT .)
    LE              reduce using rule 69 (variable -> IDENT .)
    LT              reduce using rule 69 (variable -> IDENT .)
    ^               reduce using rule 69 (variable -> IDENT .)
    /               reduce using rule 69 (variable -> IDENT .)
    *               reduce using rule 69 (variable -> IDENT .)
    -               reduce using rule 69 (variable -> IDENT .)
    +               reduce using rule 69 (variable -> IDENT .)
    ;               reduce using rule 69 (variable -> IDENT .)
    ,               reduce using rule 69 (variable -> IDENT .)
    NEWLINE         reduce using rule 69 (variable -> IDENT .)
    )               reduce using rule 69 (variable -> IDENT .)
    TO              reduce using rule 69 (variable -> IDENT .)
    THEN            reduce using rule 69 (variable -> IDENT .)
    STEP            reduce using rule 69 (variable -> IDENT .)


state 50

    (27) command -> GOTO error .
    NEWLINE         reduce using rule 27 (command -> GOTO error .)


state 51

    (28) command -> GOTO INTEGER .
    NEWLINE         reduce using rule 28 (command -> GOTO INTEGER .)


state 52

    (29) command -> PRINT error .
    NEWLINE         reduce using rule 29 (command -> PRINT error .)


state 53

    (31) command -> PRINT plist . optend
    (84) plist -> plist . sep pitem
    (43) optend -> . empty
    (44) optend -> . sep
    (88) sep -> . ;
    (89) sep -> . ,
    (90) empty -> .
    ;               shift and go to state 95
    ,               shift and go to state 96
    NEWLINE         reduce using rule 90 (empty -> .)

    optend                         shift and go to state 92
    sep                            shift and go to state 93
    empty                          shift and go to state 94

state 54

    (85) plist -> pitem .
    ;               reduce using rule 85 (plist -> pitem .)
    ,               reduce using rule 85 (plist -> pitem .)
    NEWLINE         reduce using rule 85 (plist -> pitem .)


state 55

    (86) pitem -> expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    ;               reduce using rule 86 (pitem -> expr .)
    ,               reduce using rule 86 (pitem -> expr .)
    NEWLINE         reduce using rule 86 (pitem -> expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 56

    (87) pitem -> STRING . expr
    (51) expr -> STRING .
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
  ! shift/reduce conflict for - resolved as shift
    ^               reduce using rule 51 (expr -> STRING .)
    /               reduce using rule 51 (expr -> STRING .)
    *               reduce using rule 51 (expr -> STRING .)
    +               reduce using rule 51 (expr -> STRING .)
    ;               reduce using rule 51 (expr -> STRING .)
    ,               reduce using rule 51 (expr -> STRING .)
    NEWLINE         reduce using rule 51 (expr -> STRING .)
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 97
    variable                       shift and go to state 46

state 57

    (32) command -> INPUT error .
    NEWLINE         reduce using rule 32 (command -> INPUT error .)


state 58

    (33) command -> INPUT _1_STRING_0x2c_optional . varlist
    (76) varlist -> . varlist , variable
    (77) varlist -> . variable
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    IDENT           shift and go to state 49

    varlist                        shift and go to state 98
    variable                       shift and go to state 68

state 59

    (34) _1_STRING_0x2c_optional -> STRING . ,
    ,               shift and go to state 99


state 60

    (36) command -> DATA error .
    NEWLINE         reduce using rule 36 (command -> DATA error .)


state 61

    (37) command -> DATA numlist .
    (78) numlist -> numlist . , number
    NEWLINE         reduce using rule 37 (command -> DATA numlist .)
    ,               shift and go to state 100


state 62

    (79) numlist -> number .
    ,               reduce using rule 79 (numlist -> number .)
    NEWLINE         reduce using rule 79 (numlist -> number .)


state 63

    (80) number -> - . FLOAT
    (81) number -> - . INTEGER
    FLOAT           shift and go to state 101
    INTEGER         shift and go to state 102


state 64

    (82) number -> FLOAT .
    ,               reduce using rule 82 (number -> FLOAT .)
    NEWLINE         reduce using rule 82 (number -> FLOAT .)


state 65

    (83) number -> INTEGER .
    ,               reduce using rule 83 (number -> INTEGER .)
    NEWLINE         reduce using rule 83 (number -> INTEGER .)


state 66

    (38) command -> READ error .
    NEWLINE         reduce using rule 38 (command -> READ error .)


state 67

    (39) command -> READ varlist .
    (76) varlist -> varlist . , variable
    NEWLINE         reduce using rule 39 (command -> READ varlist .)
    ,               shift and go to state 103


state 68

    (77) varlist -> variable .
    ,               reduce using rule 77 (varlist -> variable .)
    NEWLINE         reduce using rule 77 (varlist -> variable .)


state 69

    (40) command -> LET variable . = error
    (41) command -> LET variable . = expr
    =               shift and go to state 104


state 70

    (72) dimlist -> dimlist , . dimitem
    (74) dimitem -> . IDENT ( INTEGER , INTEGER )
    (75) dimitem -> . IDENT ( INTEGER )
    IDENT           shift and go to state 31

    dimitem                        shift and go to state 105

state 71

    (74) dimitem -> IDENT ( . INTEGER , INTEGER )
    (75) dimitem -> IDENT ( . INTEGER )
    INTEGER         shift and go to state 106


state 72

    (13) command -> DEF FNAME ( . error ) = expr
    (14) command -> DEF FNAME ( . IDENT ) = error
    (15) command -> DEF FNAME ( . IDENT ) = expr
    error           shift and go to state 107
    IDENT           shift and go to state 108


state 73

    (21) command -> FOR IDENT = . expr TO error optstep
    (22) command -> FOR IDENT = . error TO expr optstep
    (23) command -> FOR IDENT = . expr TO expr optstep
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    error           shift and go to state 110
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 109
    variable                       shift and go to state 46

state 74

    (24) command -> IF error THEN . INTEGER
    INTEGER         shift and go to state 111


state 75

    (25) command -> IF relexpr THEN . error
    (26) command -> IF relexpr THEN . INTEGER
    error           shift and go to state 112
    INTEGER         shift and go to state 113


state 76

    (59) relexpr -> expr NE . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 114
    variable                       shift and go to state 46

state 77

    (60) relexpr -> expr = . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 115
    variable                       shift and go to state 46

state 78

    (61) relexpr -> expr GE . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 116
    variable                       shift and go to state 46

state 79

    (62) relexpr -> expr GT . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 117
    variable                       shift and go to state 46

state 80

    (63) relexpr -> expr LE . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 118
    variable                       shift and go to state 46

state 81

    (64) relexpr -> expr LT . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 119
    variable                       shift and go to state 46

state 82

    (54) expr -> expr ^ . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 120
    variable                       shift and go to state 46

state 83

    (55) expr -> expr / . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 121
    variable                       shift and go to state 46

state 84

    (56) expr -> expr * . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 122
    variable                       shift and go to state 46

state 85

    (57) expr -> expr - . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 123
    variable                       shift and go to state 46

state 86

    (58) expr -> expr + . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 124
    variable                       shift and go to state 46

state 87

    (45) expr -> - expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NE              reduce using rule 45 (expr -> - expr .)
    =               reduce using rule 45 (expr -> - expr .)
    GE              reduce using rule 45 (expr -> - expr .)
    GT              reduce using rule 45 (expr -> - expr .)
    LE              reduce using rule 45 (expr -> - expr .)
    LT              reduce using rule 45 (expr -> - expr .)
    ^               reduce using rule 45 (expr -> - expr .)
    /               reduce using rule 45 (expr -> - expr .)
    *               reduce using rule 45 (expr -> - expr .)
    -               reduce using rule 45 (expr -> - expr .)
    +               reduce using rule 45 (expr -> - expr .)
    ;               reduce using rule 45 (expr -> - expr .)
    ,               reduce using rule 45 (expr -> - expr .)
    NEWLINE         reduce using rule 45 (expr -> - expr .)
    )               reduce using rule 45 (expr -> - expr .)
    TO              reduce using rule 45 (expr -> - expr .)
    THEN            reduce using rule 45 (expr -> - expr .)
    STEP            reduce using rule 45 (expr -> - expr .)


state 88

    (46) expr -> ( expr . )
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    )               shift and go to state 125
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 89

    (47) expr -> FNAME ( . expr )
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 126
    variable                       shift and go to state 46

state 90

    (48) expr -> BLTIN ( . expr )
    (49) expr -> BLTIN ( . )
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    )               shift and go to state 128
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 127
    variable                       shift and go to state 46

state 91

    (65) variable -> IDENT ( . expr , expr )
    (66) variable -> IDENT ( . expr )
    (67) variable -> IDENT ( . INTEGER , INTEGER )
    (68) variable -> IDENT ( . INTEGER )
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    INTEGER         shift and go to state 130
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    IDENT           shift and go to state 49

    expr                           shift and go to state 129
    variable                       shift and go to state 46

state 92

    (31) command -> PRINT plist optend .
    NEWLINE         reduce using rule 31 (command -> PRINT plist optend .)


state 93

    (84) plist -> plist sep . pitem
    (44) optend -> sep .
    (86) pitem -> . expr
    (87) pitem -> . STRING expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    NEWLINE         reduce using rule 44 (optend -> sep .)
    STRING          shift and go to state 56
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    pitem                          shift and go to state 131
    expr                           shift and go to state 55
    variable                       shift and go to state 46

state 94

    (43) optend -> empty .
    NEWLINE         reduce using rule 43 (optend -> empty .)


state 95

    (88) sep -> ; .
    STRING          reduce using rule 88 (sep -> ; .)
    -               reduce using rule 88 (sep -> ; .)
    (               reduce using rule 88 (sep -> ; .)
    FNAME           reduce using rule 88 (sep -> ; .)
    BLTIN           reduce using rule 88 (sep -> ; .)
    FLOAT           reduce using rule 88 (sep -> ; .)
    INTEGER         reduce using rule 88 (sep -> ; .)
    IDENT           reduce using rule 88 (sep -> ; .)
    NEWLINE         reduce using rule 88 (sep -> ; .)


state 96

    (89) sep -> , .
    STRING          reduce using rule 89 (sep -> , .)
    -               reduce using rule 89 (sep -> , .)
    (               reduce using rule 89 (sep -> , .)
    FNAME           reduce using rule 89 (sep -> , .)
    BLTIN           reduce using rule 89 (sep -> , .)
    FLOAT           reduce using rule 89 (sep -> , .)
    INTEGER         reduce using rule 89 (sep -> , .)
    IDENT           reduce using rule 89 (sep -> , .)
    NEWLINE         reduce using rule 89 (sep -> , .)


state 97

    (87) pitem -> STRING expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    ;               reduce using rule 87 (pitem -> STRING expr .)
    ,               reduce using rule 87 (pitem -> STRING expr .)
    NEWLINE         reduce using rule 87 (pitem -> STRING expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 98

    (33) command -> INPUT _1_STRING_0x2c_optional varlist .
    (76) varlist -> varlist . , variable
    NEWLINE         reduce using rule 33 (command -> INPUT _1_STRING_0x2c_optional varlist .)
    ,               shift and go to state 103


state 99

    (34) _1_STRING_0x2c_optional -> STRING , .
    IDENT           reduce using rule 34 (_1_STRING_0x2c_optional -> STRING , .)


state 100

    (78) numlist -> numlist , . number
    (80) number -> . - FLOAT
    (81) number -> . - INTEGER
    (82) number -> . FLOAT
    (83) number -> . INTEGER
    -               shift and go to state 63
    FLOAT           shift and go to state 64
    INTEGER         shift and go to state 65

    number                         shift and go to state 132

state 101

    (80) number -> - FLOAT .
    ,               reduce using rule 80 (number -> - FLOAT .)
    NEWLINE         reduce using rule 80 (number -> - FLOAT .)


state 102

    (81) number -> - INTEGER .
    ,               reduce using rule 81 (number -> - INTEGER .)
    NEWLINE         reduce using rule 81 (number -> - INTEGER .)


state 103

    (76) varlist -> varlist , . variable
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    IDENT           shift and go to state 49

    variable                       shift and go to state 133

state 104

    (40) command -> LET variable = . error
    (41) command -> LET variable = . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    error           shift and go to state 134
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    variable                       shift and go to state 46
    expr                           shift and go to state 135

state 105

    (72) dimlist -> dimlist , dimitem .
    ,               reduce using rule 72 (dimlist -> dimlist , dimitem .)
    NEWLINE         reduce using rule 72 (dimlist -> dimlist , dimitem .)


state 106

    (74) dimitem -> IDENT ( INTEGER . , INTEGER )
    (75) dimitem -> IDENT ( INTEGER . )
    ,               shift and go to state 136
    )               shift and go to state 137


state 107

    (13) command -> DEF FNAME ( error . ) = expr
    )               shift and go to state 138


state 108

    (14) command -> DEF FNAME ( IDENT . ) = error
    (15) command -> DEF FNAME ( IDENT . ) = expr
    )               shift and go to state 139


state 109

    (21) command -> FOR IDENT = expr . TO error optstep
    (23) command -> FOR IDENT = expr . TO expr optstep
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    TO              shift and go to state 140
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 110

    (22) command -> FOR IDENT = error . TO expr optstep
    TO              shift and go to state 141


state 111

    (24) command -> IF error THEN INTEGER .
    NEWLINE         reduce using rule 24 (command -> IF error THEN INTEGER .)


state 112

    (25) command -> IF relexpr THEN error .
    NEWLINE         reduce using rule 25 (command -> IF relexpr THEN error .)


state 113

    (26) command -> IF relexpr THEN INTEGER .
    NEWLINE         reduce using rule 26 (command -> IF relexpr THEN INTEGER .)


state 114

    (59) relexpr -> expr NE expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    THEN            reduce using rule 59 (relexpr -> expr NE expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 115

    (60) relexpr -> expr = expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    THEN            reduce using rule 60 (relexpr -> expr = expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 116

    (61) relexpr -> expr GE expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    THEN            reduce using rule 61 (relexpr -> expr GE expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 117

    (62) relexpr -> expr GT expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    THEN            reduce using rule 62 (relexpr -> expr GT expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 118

    (63) relexpr -> expr LE expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    THEN            reduce using rule 63 (relexpr -> expr LE expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 119

    (64) relexpr -> expr LT expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    THEN            reduce using rule 64 (relexpr -> expr LT expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 120

    (54) expr -> expr ^ expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NE              reduce using rule 54 (expr -> expr ^ expr .)
    =               reduce using rule 54 (expr -> expr ^ expr .)
    GE              reduce using rule 54 (expr -> expr ^ expr .)
    GT              reduce using rule 54 (expr -> expr ^ expr .)
    LE              reduce using rule 54 (expr -> expr ^ expr .)
    LT              reduce using rule 54 (expr -> expr ^ expr .)
    ^               reduce using rule 54 (expr -> expr ^ expr .)
    /               reduce using rule 54 (expr -> expr ^ expr .)
    *               reduce using rule 54 (expr -> expr ^ expr .)
    -               reduce using rule 54 (expr -> expr ^ expr .)
    +               reduce using rule 54 (expr -> expr ^ expr .)
    ;               reduce using rule 54 (expr -> expr ^ expr .)
    ,               reduce using rule 54 (expr -> expr ^ expr .)
    NEWLINE         reduce using rule 54 (expr -> expr ^ expr .)
    )               reduce using rule 54 (expr -> expr ^ expr .)
    TO              reduce using rule 54 (expr -> expr ^ expr .)
    THEN            reduce using rule 54 (expr -> expr ^ expr .)
    STEP            reduce using rule 54 (expr -> expr ^ expr .)


state 121

    (55) expr -> expr / expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NE              reduce using rule 55 (expr -> expr / expr .)
    =               reduce using rule 55 (expr -> expr / expr .)
    GE              reduce using rule 55 (expr -> expr / expr .)
    GT              reduce using rule 55 (expr -> expr / expr .)
    LE              reduce using rule 55 (expr -> expr / expr .)
    LT              reduce using rule 55 (expr -> expr / expr .)
    /               reduce using rule 55 (expr -> expr / expr .)
    *               reduce using rule 55 (expr -> expr / expr .)
    -               reduce using rule 55 (expr -> expr / expr .)
    +               reduce using rule 55 (expr -> expr / expr .)
    ;               reduce using rule 55 (expr -> expr / expr .)
    ,               reduce using rule 55 (expr -> expr / expr .)
    NEWLINE         reduce using rule 55 (expr -> expr / expr .)
    )               reduce using rule 55 (expr -> expr / expr .)
    TO              reduce using rule 55 (expr -> expr / expr .)
    THEN            reduce using rule 55 (expr -> expr / expr .)
    STEP            reduce using rule 55 (expr -> expr / expr .)
    ^               shift and go to state 82


state 122

    (56) expr -> expr * expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NE              reduce using rule 56 (expr -> expr * expr .)
    =               reduce using rule 56 (expr -> expr * expr .)
    GE              reduce using rule 56 (expr -> expr * expr .)
    GT              reduce using rule 56 (expr -> expr * expr .)
    LE              reduce using rule 56 (expr -> expr * expr .)
    LT              reduce using rule 56 (expr -> expr * expr .)
    /               reduce using rule 56 (expr -> expr * expr .)
    *               reduce using rule 56 (expr -> expr * expr .)
    -               reduce using rule 56 (expr -> expr * expr .)
    +               reduce using rule 56 (expr -> expr * expr .)
    ;               reduce using rule 56 (expr -> expr * expr .)
    ,               reduce using rule 56 (expr -> expr * expr .)
    NEWLINE         reduce using rule 56 (expr -> expr * expr .)
    )               reduce using rule 56 (expr -> expr * expr .)
    TO              reduce using rule 56 (expr -> expr * expr .)
    THEN            reduce using rule 56 (expr -> expr * expr .)
    STEP            reduce using rule 56 (expr -> expr * expr .)
    ^               shift and go to state 82


state 123

    (57) expr -> expr - expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NE              reduce using rule 57 (expr -> expr - expr .)
    =               reduce using rule 57 (expr -> expr - expr .)
    GE              reduce using rule 57 (expr -> expr - expr .)
    GT              reduce using rule 57 (expr -> expr - expr .)
    LE              reduce using rule 57 (expr -> expr - expr .)
    LT              reduce using rule 57 (expr -> expr - expr .)
    -               reduce using rule 57 (expr -> expr - expr .)
    +               reduce using rule 57 (expr -> expr - expr .)
    ;               reduce using rule 57 (expr -> expr - expr .)
    ,               reduce using rule 57 (expr -> expr - expr .)
    NEWLINE         reduce using rule 57 (expr -> expr - expr .)
    )               reduce using rule 57 (expr -> expr - expr .)
    TO              reduce using rule 57 (expr -> expr - expr .)
    THEN            reduce using rule 57 (expr -> expr - expr .)
    STEP            reduce using rule 57 (expr -> expr - expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84


state 124

    (58) expr -> expr + expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NE              reduce using rule 58 (expr -> expr + expr .)
    =               reduce using rule 58 (expr -> expr + expr .)
    GE              reduce using rule 58 (expr -> expr + expr .)
    GT              reduce using rule 58 (expr -> expr + expr .)
    LE              reduce using rule 58 (expr -> expr + expr .)
    LT              reduce using rule 58 (expr -> expr + expr .)
    -               reduce using rule 58 (expr -> expr + expr .)
    +               reduce using rule 58 (expr -> expr + expr .)
    ;               reduce using rule 58 (expr -> expr + expr .)
    ,               reduce using rule 58 (expr -> expr + expr .)
    NEWLINE         reduce using rule 58 (expr -> expr + expr .)
    )               reduce using rule 58 (expr -> expr + expr .)
    TO              reduce using rule 58 (expr -> expr + expr .)
    THEN            reduce using rule 58 (expr -> expr + expr .)
    STEP            reduce using rule 58 (expr -> expr + expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84


state 125

    (46) expr -> ( expr ) .
    NE              reduce using rule 46 (expr -> ( expr ) .)
    =               reduce using rule 46 (expr -> ( expr ) .)
    GE              reduce using rule 46 (expr -> ( expr ) .)
    GT              reduce using rule 46 (expr -> ( expr ) .)
    LE              reduce using rule 46 (expr -> ( expr ) .)
    LT              reduce using rule 46 (expr -> ( expr ) .)
    ^               reduce using rule 46 (expr -> ( expr ) .)
    /               reduce using rule 46 (expr -> ( expr ) .)
    *               reduce using rule 46 (expr -> ( expr ) .)
    -               reduce using rule 46 (expr -> ( expr ) .)
    +               reduce using rule 46 (expr -> ( expr ) .)
    ;               reduce using rule 46 (expr -> ( expr ) .)
    ,               reduce using rule 46 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 46 (expr -> ( expr ) .)
    )               reduce using rule 46 (expr -> ( expr ) .)
    TO              reduce using rule 46 (expr -> ( expr ) .)
    THEN            reduce using rule 46 (expr -> ( expr ) .)
    STEP            reduce using rule 46 (expr -> ( expr ) .)


state 126

    (47) expr -> FNAME ( expr . )
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    )               shift and go to state 142
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 127

    (48) expr -> BLTIN ( expr . )
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    )               shift and go to state 143
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 128

    (49) expr -> BLTIN ( ) .
    NE              reduce using rule 49 (expr -> BLTIN ( ) .)
    =               reduce using rule 49 (expr -> BLTIN ( ) .)
    GE              reduce using rule 49 (expr -> BLTIN ( ) .)
    GT              reduce using rule 49 (expr -> BLTIN ( ) .)
    LE              reduce using rule 49 (expr -> BLTIN ( ) .)
    LT              reduce using rule 49 (expr -> BLTIN ( ) .)
    ^               reduce using rule 49 (expr -> BLTIN ( ) .)
    /               reduce using rule 49 (expr -> BLTIN ( ) .)
    *               reduce using rule 49 (expr -> BLTIN ( ) .)
    -               reduce using rule 49 (expr -> BLTIN ( ) .)
    +               reduce using rule 49 (expr -> BLTIN ( ) .)
    ;               reduce using rule 49 (expr -> BLTIN ( ) .)
    ,               reduce using rule 49 (expr -> BLTIN ( ) .)
    NEWLINE         reduce using rule 49 (expr -> BLTIN ( ) .)
    )               reduce using rule 49 (expr -> BLTIN ( ) .)
    TO              reduce using rule 49 (expr -> BLTIN ( ) .)
    THEN            reduce using rule 49 (expr -> BLTIN ( ) .)
    STEP            reduce using rule 49 (expr -> BLTIN ( ) .)


state 129

    (65) variable -> IDENT ( expr . , expr )
    (66) variable -> IDENT ( expr . )
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    ,               shift and go to state 144
    )               shift and go to state 145
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 130

    (67) variable -> IDENT ( INTEGER . , INTEGER )
    (68) variable -> IDENT ( INTEGER . )
    (53) expr -> INTEGER .
  ! shift/reduce conflict for , resolved as shift
  ! shift/reduce conflict for ) resolved as shift
    ,               shift and go to state 146
    )               shift and go to state 147
    ^               reduce using rule 53 (expr -> INTEGER .)
    /               reduce using rule 53 (expr -> INTEGER .)
    *               reduce using rule 53 (expr -> INTEGER .)
    -               reduce using rule 53 (expr -> INTEGER .)
    +               reduce using rule 53 (expr -> INTEGER .)


state 131

    (84) plist -> plist sep pitem .
    ;               reduce using rule 84 (plist -> plist sep pitem .)
    ,               reduce using rule 84 (plist -> plist sep pitem .)
    NEWLINE         reduce using rule 84 (plist -> plist sep pitem .)


state 132

    (78) numlist -> numlist , number .
    ,               reduce using rule 78 (numlist -> numlist , number .)
    NEWLINE         reduce using rule 78 (numlist -> numlist , number .)


state 133

    (76) varlist -> varlist , variable .
    ,               reduce using rule 76 (varlist -> varlist , variable .)
    NEWLINE         reduce using rule 76 (varlist -> varlist , variable .)


state 134

    (40) command -> LET variable = error .
    NEWLINE         reduce using rule 40 (command -> LET variable = error .)


state 135

    (41) command -> LET variable = expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NEWLINE         reduce using rule 41 (command -> LET variable = expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 136

    (74) dimitem -> IDENT ( INTEGER , . INTEGER )
    INTEGER         shift and go to state 148


state 137

    (75) dimitem -> IDENT ( INTEGER ) .
    ,               reduce using rule 75 (dimitem -> IDENT ( INTEGER ) .)
    NEWLINE         reduce using rule 75 (dimitem -> IDENT ( INTEGER ) .)


state 138

    (13) command -> DEF FNAME ( error ) . = expr
    =               shift and go to state 149


state 139

    (14) command -> DEF FNAME ( IDENT ) . = error
    (15) command -> DEF FNAME ( IDENT ) . = expr
    =               shift and go to state 150


state 140

    (21) command -> FOR IDENT = expr TO . error optstep
    (23) command -> FOR IDENT = expr TO . expr optstep
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    error           shift and go to state 152
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 151
    variable                       shift and go to state 46

state 141

    (22) command -> FOR IDENT = error TO . expr optstep
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 153
    variable                       shift and go to state 46

state 142

    (47) expr -> FNAME ( expr ) .
    NE              reduce using rule 47 (expr -> FNAME ( expr ) .)
    =               reduce using rule 47 (expr -> FNAME ( expr ) .)
    GE              reduce using rule 47 (expr -> FNAME ( expr ) .)
    GT              reduce using rule 47 (expr -> FNAME ( expr ) .)
    LE              reduce using rule 47 (expr -> FNAME ( expr ) .)
    LT              reduce using rule 47 (expr -> FNAME ( expr ) .)
    ^               reduce using rule 47 (expr -> FNAME ( expr ) .)
    /               reduce using rule 47 (expr -> FNAME ( expr ) .)
    *               reduce using rule 47 (expr -> FNAME ( expr ) .)
    -               reduce using rule 47 (expr -> FNAME ( expr ) .)
    +               reduce using rule 47 (expr -> FNAME ( expr ) .)
    ;               reduce using rule 47 (expr -> FNAME ( expr ) .)
    ,               reduce using rule 47 (expr -> FNAME ( expr ) .)
    NEWLINE         reduce using rule 47 (expr -> FNAME ( expr ) .)
    )               reduce using rule 47 (expr -> FNAME ( expr ) .)
    TO              reduce using rule 47 (expr -> FNAME ( expr ) .)
    THEN            reduce using rule 47 (expr -> FNAME ( expr ) .)
    STEP            reduce using rule 47 (expr -> FNAME ( expr ) .)


state 143

    (48) expr -> BLTIN ( expr ) .
    NE              reduce using rule 48 (expr -> BLTIN ( expr ) .)
    =               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    GE              reduce using rule 48 (expr -> BLTIN ( expr ) .)
    GT              reduce using rule 48 (expr -> BLTIN ( expr ) .)
    LE              reduce using rule 48 (expr -> BLTIN ( expr ) .)
    LT              reduce using rule 48 (expr -> BLTIN ( expr ) .)
    ^               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    /               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    *               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    -               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    +               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    ;               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    ,               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    NEWLINE         reduce using rule 48 (expr -> BLTIN ( expr ) .)
    )               reduce using rule 48 (expr -> BLTIN ( expr ) .)
    TO              reduce using rule 48 (expr -> BLTIN ( expr ) .)
    THEN            reduce using rule 48 (expr -> BLTIN ( expr ) .)
    STEP            reduce using rule 48 (expr -> BLTIN ( expr ) .)


state 144

    (65) variable -> IDENT ( expr , . expr )
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 154
    variable                       shift and go to state 46

state 145

    (66) variable -> IDENT ( expr ) .
    NE              reduce using rule 66 (variable -> IDENT ( expr ) .)
    =               reduce using rule 66 (variable -> IDENT ( expr ) .)
    GE              reduce using rule 66 (variable -> IDENT ( expr ) .)
    GT              reduce using rule 66 (variable -> IDENT ( expr ) .)
    LE              reduce using rule 66 (variable -> IDENT ( expr ) .)
    LT              reduce using rule 66 (variable -> IDENT ( expr ) .)
    ^               reduce using rule 66 (variable -> IDENT ( expr ) .)
    /               reduce using rule 66 (variable -> IDENT ( expr ) .)
    *               reduce using rule 66 (variable -> IDENT ( expr ) .)
    -               reduce using rule 66 (variable -> IDENT ( expr ) .)
    +               reduce using rule 66 (variable -> IDENT ( expr ) .)
    ;               reduce using rule 66 (variable -> IDENT ( expr ) .)
    ,               reduce using rule 66 (variable -> IDENT ( expr ) .)
    NEWLINE         reduce using rule 66 (variable -> IDENT ( expr ) .)
    )               reduce using rule 66 (variable -> IDENT ( expr ) .)
    TO              reduce using rule 66 (variable -> IDENT ( expr ) .)
    THEN            reduce using rule 66 (variable -> IDENT ( expr ) .)
    STEP            reduce using rule 66 (variable -> IDENT ( expr ) .)


state 146

    (67) variable -> IDENT ( INTEGER , . INTEGER )
    INTEGER         shift and go to state 155


state 147

    (68) variable -> IDENT ( INTEGER ) .
    NE              reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    =               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    GE              reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    GT              reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    LE              reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    LT              reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    ^               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    /               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    *               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    -               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    +               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    ;               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    ,               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    NEWLINE         reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    )               reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    TO              reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    THEN            reduce using rule 68 (variable -> IDENT ( INTEGER ) .)
    STEP            reduce using rule 68 (variable -> IDENT ( INTEGER ) .)


state 148

    (74) dimitem -> IDENT ( INTEGER , INTEGER . )
    )               shift and go to state 156


state 149

    (13) command -> DEF FNAME ( error ) = . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 157
    variable                       shift and go to state 46

state 150

    (14) command -> DEF FNAME ( IDENT ) = . error
    (15) command -> DEF FNAME ( IDENT ) = . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    error           shift and go to state 158
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 159
    variable                       shift and go to state 46

state 151

    (23) command -> FOR IDENT = expr TO expr . optstep
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (70) optstep -> . empty
    (71) optstep -> . STEP expr
    (90) empty -> .
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86
    STEP            shift and go to state 162
    NEWLINE         reduce using rule 90 (empty -> .)

    optstep                        shift and go to state 160
    empty                          shift and go to state 161

state 152

    (21) command -> FOR IDENT = expr TO error . optstep
    (70) optstep -> . empty
    (71) optstep -> . STEP expr
    (90) empty -> .
    STEP            shift and go to state 162
    NEWLINE         reduce using rule 90 (empty -> .)

    optstep                        shift and go to state 163
    empty                          shift and go to state 161

state 153

    (22) command -> FOR IDENT = error TO expr . optstep
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    (70) optstep -> . empty
    (71) optstep -> . STEP expr
    (90) empty -> .
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86
    STEP            shift and go to state 162
    NEWLINE         reduce using rule 90 (empty -> .)

    optstep                        shift and go to state 164
    empty                          shift and go to state 161

state 154

    (65) variable -> IDENT ( expr , expr . )
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    )               shift and go to state 165
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 155

    (67) variable -> IDENT ( INTEGER , INTEGER . )
    )               shift and go to state 166


state 156

    (74) dimitem -> IDENT ( INTEGER , INTEGER ) .
    ,               reduce using rule 74 (dimitem -> IDENT ( INTEGER , INTEGER ) .)
    NEWLINE         reduce using rule 74 (dimitem -> IDENT ( INTEGER , INTEGER ) .)


state 157

    (13) command -> DEF FNAME ( error ) = expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NEWLINE         reduce using rule 13 (command -> DEF FNAME ( error ) = expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 158

    (14) command -> DEF FNAME ( IDENT ) = error .
    NEWLINE         reduce using rule 14 (command -> DEF FNAME ( IDENT ) = error .)


state 159

    (15) command -> DEF FNAME ( IDENT ) = expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NEWLINE         reduce using rule 15 (command -> DEF FNAME ( IDENT ) = expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


state 160

    (23) command -> FOR IDENT = expr TO expr optstep .
    NEWLINE         reduce using rule 23 (command -> FOR IDENT = expr TO expr optstep .)


state 161

    (70) optstep -> empty .
    NEWLINE         reduce using rule 70 (optstep -> empty .)


state 162

    (71) optstep -> STEP . expr
    (45) expr -> . - expr
    (46) expr -> . ( expr )
    (47) expr -> . FNAME ( expr )
    (48) expr -> . BLTIN ( expr )
    (49) expr -> . BLTIN ( )
    (50) expr -> . variable
    (51) expr -> . STRING
    (52) expr -> . FLOAT
    (53) expr -> . INTEGER
    (54) expr -> . expr ^ expr
    (55) expr -> . expr / expr
    (56) expr -> . expr * expr
    (57) expr -> . expr - expr
    (58) expr -> . expr + expr
    (65) variable -> . IDENT ( expr , expr )
    (66) variable -> . IDENT ( expr )
    (67) variable -> . IDENT ( INTEGER , INTEGER )
    (68) variable -> . IDENT ( INTEGER )
    (69) variable -> . IDENT
    -               shift and go to state 42
    (               shift and go to state 43
    FNAME           shift and go to state 44
    BLTIN           shift and go to state 45
    STRING          shift and go to state 47
    FLOAT           shift and go to state 48
    INTEGER         shift and go to state 39
    IDENT           shift and go to state 49

    expr                           shift and go to state 167
    variable                       shift and go to state 46

state 163

    (21) command -> FOR IDENT = expr TO error optstep .
    NEWLINE         reduce using rule 21 (command -> FOR IDENT = expr TO error optstep .)


state 164

    (22) command -> FOR IDENT = error TO expr optstep .
    NEWLINE         reduce using rule 22 (command -> FOR IDENT = error TO expr optstep .)


state 165

    (65) variable -> IDENT ( expr , expr ) .
    NE              reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    =               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    GE              reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    GT              reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    LE              reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    LT              reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    ^               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    /               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    *               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    -               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    +               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    ;               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    ,               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    NEWLINE         reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    )               reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    TO              reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    THEN            reduce using rule 65 (variable -> IDENT ( expr , expr ) .)
    STEP            reduce using rule 65 (variable -> IDENT ( expr , expr ) .)


state 166

    (67) variable -> IDENT ( INTEGER , INTEGER ) .
    NE              reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    =               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    GE              reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    GT              reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    LE              reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    LT              reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    ^               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    /               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    *               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    -               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    +               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    ;               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    ,               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    NEWLINE         reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    )               reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    TO              reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    THEN            reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)
    STEP            reduce using rule 67 (variable -> IDENT ( INTEGER , INTEGER ) .)


state 167

    (71) optstep -> STEP expr .
    (54) expr -> expr . ^ expr
    (55) expr -> expr . / expr
    (56) expr -> expr . * expr
    (57) expr -> expr . - expr
    (58) expr -> expr . + expr
    NEWLINE         reduce using rule 71 (optstep -> STEP expr .)
    ^               shift and go to state 82
    /               shift and go to state 83
    *               shift and go to state 84
    -               shift and go to state 85
    +               shift and go to state 86


Conflicts:

shift/reduce conflict for NEWLINE in state 9 resolved as shift
shift/reduce conflict for - in state 56 resolved as shift
shift/reduce conflict for , in state 130 resolved as shift
shift/reduce conflict for ) in state 130 resolved as shift