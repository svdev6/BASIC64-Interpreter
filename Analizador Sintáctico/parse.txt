Grammar:

Rule 0     S' -> program
Rule 1     program -> error
Rule 2     program -> stmt
Rule 3     program -> program stmt
Rule 4     stmt -> NEWLINE
Rule 5     stmt -> INTEGER NEWLINE
Rule 6     stmt -> INTEGER error NEWLINE
Rule 7     stmt -> INTEGER command NEWLINE
Rule 8     command -> DIM error
Rule 9     command -> DIM dimlist
Rule 10    command -> RETURN
Rule 11    command -> GOSUB error
Rule 12    command -> GOSUB INTEGER
Rule 13    command -> DEF FNAME ( error ) = expr
Rule 14    command -> DEF FNAME ( IDENT ) = error
Rule 15    command -> DEF FNAME ( IDENT ) = expr
Rule 16    command -> STOP
Rule 17    command -> REM
Rule 18    command -> END
Rule 19    command -> NEXT error
Rule 20    command -> NEXT IDENT
Rule 21    command -> FOR IDENT = expr TO error optstep
Rule 22    command -> FOR IDENT = error TO expr optstep
Rule 23    command -> FOR IDENT = expr TO expr optstep
Rule 24    command -> IF error THEN INTEGER
Rule 25    command -> IF relexpr THEN error
Rule 26    command -> IF relexpr THEN INTEGER
Rule 27    command -> GOTO error
Rule 28    command -> GOTO INTEGER
Rule 29    command -> PRINT error
Rule 30    command -> PRINT
Rule 31    command -> PRINT plist optend
Rule 32    command -> INPUT error
Rule 33    command -> INPUT _1_STRING_sep_optional varlist
Rule 34    _1_STRING_sep_optional -> STRING sep
Rule 35    _1_STRING_sep_optional -> <empty>
Rule 36    command -> DATA error
Rule 37    command -> DATA mixedlist
Rule 38    command -> READ error
Rule 39    command -> RESTORE
Rule 40    command -> READ varlist
Rule 41    command -> LET variable = error
Rule 42    command -> LET variable = expr
Rule 43    command -> command
Rule 44    mixedlist -> mixedlist , mixeditem
Rule 45    mixedlist -> mixeditem
Rule 46    mixeditem -> STRING
Rule 47    mixeditem -> number
Rule 48    optend -> empty
Rule 49    optend -> sep
Rule 50    expr -> - expr  [precedence=right, level=4]
Rule 51    expr -> ( expr )
Rule 52    expr -> FNAME ( exprlist )
Rule 53    expr -> BLTIN ( exprlist )
Rule 54    expr -> BLTIN ( )
Rule 55    expr -> variable
Rule 56    expr -> STRING
Rule 57    expr -> FLOAT
Rule 58    expr -> INTEGER
Rule 59    expr -> expr ^ expr  [precedence=left, level=3]
Rule 60    expr -> expr / expr  [precedence=left, level=2]
Rule 61    expr -> expr * expr  [precedence=left, level=2]
Rule 62    expr -> expr - expr  [precedence=left, level=1]
Rule 63    expr -> expr + expr  [precedence=left, level=1]
Rule 64    exprlist -> exprlist , expr
Rule 65    exprlist -> expr
Rule 66    relexpr -> expr NE expr
Rule 67    relexpr -> expr = expr
Rule 68    relexpr -> expr GE expr
Rule 69    relexpr -> expr GT expr
Rule 70    relexpr -> expr LE expr
Rule 71    relexpr -> expr LT expr
Rule 72    variable -> IDENT ( expr , expr )
Rule 73    variable -> IDENT ( expr )
Rule 74    variable -> IDENT
Rule 75    optstep -> empty
Rule 76    optstep -> STEP expr
Rule 77    dimitem -> IDENT ( INTEGER , INTEGER )
Rule 78    dimitem -> IDENT ( INTEGER )
Rule 79    dimlist -> dimlist , dimitem
Rule 80    dimlist -> dimitem
Rule 81    varlist -> varlist , variable
Rule 82    varlist -> variable
Rule 83    number -> - FLOAT  [precedence=right, level=4]
Rule 84    number -> - INTEGER  [precedence=right, level=4]
Rule 85    number -> FLOAT
Rule 86    number -> INTEGER
Rule 87    plist -> plist sep pitem
Rule 88    plist -> pitem
Rule 89    pitem -> expr
Rule 90    pitem -> STRING expr
Rule 91    sep -> ;
Rule 92    sep -> ,
Rule 93    empty -> <empty>

Terminals, with rules where they appear:

(                    : 13 14 15 51 52 53 54 72 73 77 78
)                    : 13 14 15 51 52 53 54 72 73 77 78
*                    : 61
+                    : 63
,                    : 44 64 72 77 79 81 92
-                    : 50 62 83 84
/                    : 60
;                    : 91
=                    : 13 14 15 21 22 23 41 42 67
BLTIN                : 53 54
DATA                 : 36 37
DEF                  : 13 14 15
DIM                  : 8 9
END                  : 18
FLOAT                : 57 83 85
FNAME                : 13 14 15 52
FOR                  : 21 22 23
GE                   : 68
GOSUB                : 11 12
GOTO                 : 27 28
GT                   : 69
IDENT                : 14 15 20 21 22 23 72 73 74 77 78
IF                   : 24 25 26
INPUT                : 32 33
INTEGER              : 5 6 7 12 24 26 28 58 77 77 78 84 86
LE                   : 70
LET                  : 41 42
LT                   : 71
NE                   : 66
NEWLINE              : 4 5 6 7
NEXT                 : 19 20
PRINT                : 29 30 31
READ                 : 38 40
REM                  : 17
RESTORE              : 39
RETURN               : 10
STEP                 : 76
STOP                 : 16
STRING               : 34 46 56 90
THEN                 : 24 25 26
TO                   : 21 22 23
^                    : 59
error                : 1 6 8 11 13 14 19 21 22 24 25 27 29 32 36 38 41

Nonterminals, with rules where they appear:

_1_STRING_sep_optional : 33
command              : 7 43
dimitem              : 79 80
dimlist              : 9 79
empty                : 48 75
expr                 : 13 15 21 22 23 23 42 50 51 59 59 60 60 61 61 62 62 63 63 64 65 66 66 67 67 68 68 69 69 70 70 71 71 72 72 73 76 89 90
exprlist             : 52 53 64
mixeditem            : 44 45
mixedlist            : 37 44
number               : 47
optend               : 31
optstep              : 21 22 23
pitem                : 87 88
plist                : 31 87
program              : 3 0
relexpr              : 25 26
sep                  : 34 49 87
stmt                 : 2 3
variable             : 41 42 55 81 82
varlist              : 33 40 81


state 0

    (0) S' -> . program
    (1) program -> . error
    (2) program -> . stmt
    (3) program -> . program stmt
    (4) stmt -> . NEWLINE
    (5) stmt -> . INTEGER NEWLINE
    (6) stmt -> . INTEGER error NEWLINE
    (7) stmt -> . INTEGER command NEWLINE
    error           shift and go to state 2
    NEWLINE         shift and go to state 4
    INTEGER         shift and go to state 5

    program                        shift and go to state 1
    stmt                           shift and go to state 3

state 1

    (0) S' -> program .
    (3) program -> program . stmt
    (4) stmt -> . NEWLINE
    (5) stmt -> . INTEGER NEWLINE
    (6) stmt -> . INTEGER error NEWLINE
    (7) stmt -> . INTEGER command NEWLINE
    NEWLINE         shift and go to state 4
    INTEGER         shift and go to state 5

    stmt                           shift and go to state 6

state 2

    (1) program -> error .
    NEWLINE         reduce using rule 1 (program -> error .)
    INTEGER         reduce using rule 1 (program -> error .)
    $end            reduce using rule 1 (program -> error .)


state 3

    (2) program -> stmt .
    NEWLINE         reduce using rule 2 (program -> stmt .)
    INTEGER         reduce using rule 2 (program -> stmt .)
    $end            reduce using rule 2 (program -> stmt .)


state 4

    (4) stmt -> NEWLINE .
    NEWLINE         reduce using rule 4 (stmt -> NEWLINE .)
    INTEGER         reduce using rule 4 (stmt -> NEWLINE .)
    $end            reduce using rule 4 (stmt -> NEWLINE .)


state 5

    (5) stmt -> INTEGER . NEWLINE
    (6) stmt -> INTEGER . error NEWLINE
    (7) stmt -> INTEGER . command NEWLINE
    (8) command -> . DIM error
    (9) command -> . DIM dimlist
    (10) command -> . RETURN
    (11) command -> . GOSUB error
    (12) command -> . GOSUB INTEGER
    (13) command -> . DEF FNAME ( error ) = expr
    (14) command -> . DEF FNAME ( IDENT ) = error
    (15) command -> . DEF FNAME ( IDENT ) = expr
    (16) command -> . STOP
    (17) command -> . REM
    (18) command -> . END
    (19) command -> . NEXT error
    (20) command -> . NEXT IDENT
    (21) command -> . FOR IDENT = expr TO error optstep
    (22) command -> . FOR IDENT = error TO expr optstep
    (23) command -> . FOR IDENT = expr TO expr optstep
    (24) command -> . IF error THEN INTEGER
    (25) command -> . IF relexpr THEN error
    (26) command -> . IF relexpr THEN INTEGER
    (27) command -> . GOTO error
    (28) command -> . GOTO INTEGER
    (29) command -> . PRINT error
    (30) command -> . PRINT
    (31) command -> . PRINT plist optend
    (32) command -> . INPUT error
    (33) command -> . INPUT _1_STRING_sep_optional varlist
    (36) command -> . DATA error
    (37) command -> . DATA mixedlist
    (38) command -> . READ error
    (39) command -> . RESTORE
    (40) command -> . READ varlist
    (41) command -> . LET variable = error
    (42) command -> . LET variable = expr
    (43) command -> . command
    NEWLINE         shift and go to state 7
    error           shift and go to state 8
    DIM             shift and go to state 10
    RETURN          shift and go to state 11
    GOSUB           shift and go to state 12
    DEF             shift and go to state 13
    STOP            shift and go to state 14
    REM             shift and go to state 15
    END             shift and go to state 16
    NEXT            shift and go to state 17
    FOR             shift and go to state 18
    IF              shift and go to state 19
    GOTO            shift and go to state 20
    PRINT           shift and go to state 21
    INPUT           shift and go to state 22
    DATA            shift and go to state 23
    READ            shift and go to state 24
    RESTORE         shift and go to state 25
    LET             shift and go to state 26

    command                        shift and go to state 9

state 6

    (3) program -> program stmt .
    NEWLINE         reduce using rule 3 (program -> program stmt .)
    INTEGER         reduce using rule 3 (program -> program stmt .)
    $end            reduce using rule 3 (program -> program stmt .)


state 7

    (5) stmt -> INTEGER NEWLINE .
    NEWLINE         reduce using rule 5 (stmt -> INTEGER NEWLINE .)
    INTEGER         reduce using rule 5 (stmt -> INTEGER NEWLINE .)
    $end            reduce using rule 5 (stmt -> INTEGER NEWLINE .)


state 8

    (6) stmt -> INTEGER error . NEWLINE
    NEWLINE         shift and go to state 27


state 9

    (7) stmt -> INTEGER command . NEWLINE
    (43) command -> command .
  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 28


state 10

    (8) command -> DIM . error
    (9) command -> DIM . dimlist
    (79) dimlist -> . dimlist , dimitem
    (80) dimlist -> . dimitem
    (77) dimitem -> . IDENT ( INTEGER , INTEGER )
    (78) dimitem -> . IDENT ( INTEGER )
    error           shift and go to state 29
    IDENT           shift and go to state 32

    dimlist                        shift and go to state 30
    dimitem                        shift and go to state 31

state 11

    (10) command -> RETURN .
    NEWLINE         reduce using rule 10 (command -> RETURN .)


state 12

    (11) command -> GOSUB . error
    (12) command -> GOSUB . INTEGER
    error           shift and go to state 33
    INTEGER         shift and go to state 34


state 13

    (13) command -> DEF . FNAME ( error ) = expr
    (14) command -> DEF . FNAME ( IDENT ) = error
    (15) command -> DEF . FNAME ( IDENT ) = expr
    FNAME           shift and go to state 35


state 14

    (16) command -> STOP .
    NEWLINE         reduce using rule 16 (command -> STOP .)


state 15

    (17) command -> REM .
    NEWLINE         reduce using rule 17 (command -> REM .)


state 16

    (18) command -> END .
    NEWLINE         reduce using rule 18 (command -> END .)


state 17

    (19) command -> NEXT . error
    (20) command -> NEXT . IDENT
    error           shift and go to state 36
    IDENT           shift and go to state 37


state 18

    (21) command -> FOR . IDENT = expr TO error optstep
    (22) command -> FOR . IDENT = error TO expr optstep
    (23) command -> FOR . IDENT = expr TO expr optstep
    IDENT           shift and go to state 38


state 19

    (24) command -> IF . error THEN INTEGER
    (25) command -> IF . relexpr THEN error
    (26) command -> IF . relexpr THEN INTEGER
    (66) relexpr -> . expr NE expr
    (67) relexpr -> . expr = expr
    (68) relexpr -> . expr GE expr
    (69) relexpr -> . expr GT expr
    (70) relexpr -> . expr LE expr
    (71) relexpr -> . expr LT expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    error           shift and go to state 39
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    relexpr                        shift and go to state 41
    expr                           shift and go to state 42
    variable                       shift and go to state 47

state 20

    (27) command -> GOTO . error
    (28) command -> GOTO . INTEGER
    error           shift and go to state 51
    INTEGER         shift and go to state 52


state 21

    (29) command -> PRINT . error
    (30) command -> PRINT .
    (31) command -> PRINT . plist optend
    (87) plist -> . plist sep pitem
    (88) plist -> . pitem
    (89) pitem -> . expr
    (90) pitem -> . STRING expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    error           shift and go to state 53
    NEWLINE         reduce using rule 30 (command -> PRINT .)
    STRING          shift and go to state 57
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    plist                          shift and go to state 54
    pitem                          shift and go to state 55
    expr                           shift and go to state 56
    variable                       shift and go to state 47

state 22

    (32) command -> INPUT . error
    (33) command -> INPUT . _1_STRING_sep_optional varlist
    (34) _1_STRING_sep_optional -> . STRING sep
    (35) _1_STRING_sep_optional -> .
    error           shift and go to state 58
    STRING          shift and go to state 60
    IDENT           reduce using rule 35 (_1_STRING_sep_optional -> .)

    _1_STRING_sep_optional         shift and go to state 59

state 23

    (36) command -> DATA . error
    (37) command -> DATA . mixedlist
    (44) mixedlist -> . mixedlist , mixeditem
    (45) mixedlist -> . mixeditem
    (46) mixeditem -> . STRING
    (47) mixeditem -> . number
    (83) number -> . - FLOAT
    (84) number -> . - INTEGER
    (85) number -> . FLOAT
    (86) number -> . INTEGER
    error           shift and go to state 61
    STRING          shift and go to state 64
    -               shift and go to state 66
    FLOAT           shift and go to state 67
    INTEGER         shift and go to state 68

    mixedlist                      shift and go to state 62
    mixeditem                      shift and go to state 63
    number                         shift and go to state 65

state 24

    (38) command -> READ . error
    (40) command -> READ . varlist
    (81) varlist -> . varlist , variable
    (82) varlist -> . variable
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    error           shift and go to state 69
    IDENT           shift and go to state 50

    varlist                        shift and go to state 70
    variable                       shift and go to state 71

state 25

    (39) command -> RESTORE .
    NEWLINE         reduce using rule 39 (command -> RESTORE .)


state 26

    (41) command -> LET . variable = error
    (42) command -> LET . variable = expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    IDENT           shift and go to state 50

    variable                       shift and go to state 72

state 27

    (6) stmt -> INTEGER error NEWLINE .
    NEWLINE         reduce using rule 6 (stmt -> INTEGER error NEWLINE .)
    INTEGER         reduce using rule 6 (stmt -> INTEGER error NEWLINE .)
    $end            reduce using rule 6 (stmt -> INTEGER error NEWLINE .)


state 28

    (7) stmt -> INTEGER command NEWLINE .
    NEWLINE         reduce using rule 7 (stmt -> INTEGER command NEWLINE .)
    INTEGER         reduce using rule 7 (stmt -> INTEGER command NEWLINE .)
    $end            reduce using rule 7 (stmt -> INTEGER command NEWLINE .)


state 29

    (8) command -> DIM error .
    NEWLINE         reduce using rule 8 (command -> DIM error .)


state 30

    (9) command -> DIM dimlist .
    (79) dimlist -> dimlist . , dimitem
    NEWLINE         reduce using rule 9 (command -> DIM dimlist .)
    ,               shift and go to state 73


state 31

    (80) dimlist -> dimitem .
    ,               reduce using rule 80 (dimlist -> dimitem .)
    NEWLINE         reduce using rule 80 (dimlist -> dimitem .)


state 32

    (77) dimitem -> IDENT . ( INTEGER , INTEGER )
    (78) dimitem -> IDENT . ( INTEGER )
    (               shift and go to state 74


state 33

    (11) command -> GOSUB error .
    NEWLINE         reduce using rule 11 (command -> GOSUB error .)


state 34

    (12) command -> GOSUB INTEGER .
    NEWLINE         reduce using rule 12 (command -> GOSUB INTEGER .)


state 35

    (13) command -> DEF FNAME . ( error ) = expr
    (14) command -> DEF FNAME . ( IDENT ) = error
    (15) command -> DEF FNAME . ( IDENT ) = expr
    (               shift and go to state 75


state 36

    (19) command -> NEXT error .
    NEWLINE         reduce using rule 19 (command -> NEXT error .)


state 37

    (20) command -> NEXT IDENT .
    NEWLINE         reduce using rule 20 (command -> NEXT IDENT .)


state 38

    (21) command -> FOR IDENT . = expr TO error optstep
    (22) command -> FOR IDENT . = error TO expr optstep
    (23) command -> FOR IDENT . = expr TO expr optstep
    =               shift and go to state 76


state 39

    (24) command -> IF error . THEN INTEGER
    THEN            shift and go to state 77


state 40

    (58) expr -> INTEGER .
    NE              reduce using rule 58 (expr -> INTEGER .)
    =               reduce using rule 58 (expr -> INTEGER .)
    GE              reduce using rule 58 (expr -> INTEGER .)
    GT              reduce using rule 58 (expr -> INTEGER .)
    LE              reduce using rule 58 (expr -> INTEGER .)
    LT              reduce using rule 58 (expr -> INTEGER .)
    ^               reduce using rule 58 (expr -> INTEGER .)
    /               reduce using rule 58 (expr -> INTEGER .)
    *               reduce using rule 58 (expr -> INTEGER .)
    -               reduce using rule 58 (expr -> INTEGER .)
    +               reduce using rule 58 (expr -> INTEGER .)
    ;               reduce using rule 58 (expr -> INTEGER .)
    ,               reduce using rule 58 (expr -> INTEGER .)
    NEWLINE         reduce using rule 58 (expr -> INTEGER .)
    )               reduce using rule 58 (expr -> INTEGER .)
    TO              reduce using rule 58 (expr -> INTEGER .)
    THEN            reduce using rule 58 (expr -> INTEGER .)
    STEP            reduce using rule 58 (expr -> INTEGER .)


state 41

    (25) command -> IF relexpr . THEN error
    (26) command -> IF relexpr . THEN INTEGER
    THEN            shift and go to state 78


state 42

    (66) relexpr -> expr . NE expr
    (67) relexpr -> expr . = expr
    (68) relexpr -> expr . GE expr
    (69) relexpr -> expr . GT expr
    (70) relexpr -> expr . LE expr
    (71) relexpr -> expr . LT expr
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NE              shift and go to state 79
    =               shift and go to state 80
    GE              shift and go to state 81
    GT              shift and go to state 82
    LE              shift and go to state 83
    LT              shift and go to state 84
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 43

    (50) expr -> - . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 90
    variable                       shift and go to state 47

state 44

    (51) expr -> ( . expr )
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 91
    variable                       shift and go to state 47

state 45

    (52) expr -> FNAME . ( exprlist )
    (               shift and go to state 92


state 46

    (53) expr -> BLTIN . ( exprlist )
    (54) expr -> BLTIN . ( )
    (               shift and go to state 93


state 47

    (55) expr -> variable .
    NE              reduce using rule 55 (expr -> variable .)
    =               reduce using rule 55 (expr -> variable .)
    GE              reduce using rule 55 (expr -> variable .)
    GT              reduce using rule 55 (expr -> variable .)
    LE              reduce using rule 55 (expr -> variable .)
    LT              reduce using rule 55 (expr -> variable .)
    ^               reduce using rule 55 (expr -> variable .)
    /               reduce using rule 55 (expr -> variable .)
    *               reduce using rule 55 (expr -> variable .)
    -               reduce using rule 55 (expr -> variable .)
    +               reduce using rule 55 (expr -> variable .)
    ;               reduce using rule 55 (expr -> variable .)
    ,               reduce using rule 55 (expr -> variable .)
    NEWLINE         reduce using rule 55 (expr -> variable .)
    )               reduce using rule 55 (expr -> variable .)
    TO              reduce using rule 55 (expr -> variable .)
    THEN            reduce using rule 55 (expr -> variable .)
    STEP            reduce using rule 55 (expr -> variable .)


state 48

    (56) expr -> STRING .
    NE              reduce using rule 56 (expr -> STRING .)
    =               reduce using rule 56 (expr -> STRING .)
    GE              reduce using rule 56 (expr -> STRING .)
    GT              reduce using rule 56 (expr -> STRING .)
    LE              reduce using rule 56 (expr -> STRING .)
    LT              reduce using rule 56 (expr -> STRING .)
    ^               reduce using rule 56 (expr -> STRING .)
    /               reduce using rule 56 (expr -> STRING .)
    *               reduce using rule 56 (expr -> STRING .)
    -               reduce using rule 56 (expr -> STRING .)
    +               reduce using rule 56 (expr -> STRING .)
    ;               reduce using rule 56 (expr -> STRING .)
    ,               reduce using rule 56 (expr -> STRING .)
    NEWLINE         reduce using rule 56 (expr -> STRING .)
    )               reduce using rule 56 (expr -> STRING .)
    TO              reduce using rule 56 (expr -> STRING .)
    THEN            reduce using rule 56 (expr -> STRING .)
    STEP            reduce using rule 56 (expr -> STRING .)


state 49

    (57) expr -> FLOAT .
    NE              reduce using rule 57 (expr -> FLOAT .)
    =               reduce using rule 57 (expr -> FLOAT .)
    GE              reduce using rule 57 (expr -> FLOAT .)
    GT              reduce using rule 57 (expr -> FLOAT .)
    LE              reduce using rule 57 (expr -> FLOAT .)
    LT              reduce using rule 57 (expr -> FLOAT .)
    ^               reduce using rule 57 (expr -> FLOAT .)
    /               reduce using rule 57 (expr -> FLOAT .)
    *               reduce using rule 57 (expr -> FLOAT .)
    -               reduce using rule 57 (expr -> FLOAT .)
    +               reduce using rule 57 (expr -> FLOAT .)
    ;               reduce using rule 57 (expr -> FLOAT .)
    ,               reduce using rule 57 (expr -> FLOAT .)
    NEWLINE         reduce using rule 57 (expr -> FLOAT .)
    )               reduce using rule 57 (expr -> FLOAT .)
    TO              reduce using rule 57 (expr -> FLOAT .)
    THEN            reduce using rule 57 (expr -> FLOAT .)
    STEP            reduce using rule 57 (expr -> FLOAT .)


state 50

    (72) variable -> IDENT . ( expr , expr )
    (73) variable -> IDENT . ( expr )
    (74) variable -> IDENT .
    (               shift and go to state 94
    NE              reduce using rule 74 (variable -> IDENT .)
    =               reduce using rule 74 (variable -> IDENT .)
    GE              reduce using rule 74 (variable -> IDENT .)
    GT              reduce using rule 74 (variable -> IDENT .)
    LE              reduce using rule 74 (variable -> IDENT .)
    LT              reduce using rule 74 (variable -> IDENT .)
    ^               reduce using rule 74 (variable -> IDENT .)
    /               reduce using rule 74 (variable -> IDENT .)
    *               reduce using rule 74 (variable -> IDENT .)
    -               reduce using rule 74 (variable -> IDENT .)
    +               reduce using rule 74 (variable -> IDENT .)
    ;               reduce using rule 74 (variable -> IDENT .)
    ,               reduce using rule 74 (variable -> IDENT .)
    NEWLINE         reduce using rule 74 (variable -> IDENT .)
    )               reduce using rule 74 (variable -> IDENT .)
    TO              reduce using rule 74 (variable -> IDENT .)
    THEN            reduce using rule 74 (variable -> IDENT .)
    STEP            reduce using rule 74 (variable -> IDENT .)


state 51

    (27) command -> GOTO error .
    NEWLINE         reduce using rule 27 (command -> GOTO error .)


state 52

    (28) command -> GOTO INTEGER .
    NEWLINE         reduce using rule 28 (command -> GOTO INTEGER .)


state 53

    (29) command -> PRINT error .
    NEWLINE         reduce using rule 29 (command -> PRINT error .)


state 54

    (31) command -> PRINT plist . optend
    (87) plist -> plist . sep pitem
    (48) optend -> . empty
    (49) optend -> . sep
    (91) sep -> . ;
    (92) sep -> . ,
    (93) empty -> .
    ;               shift and go to state 98
    ,               shift and go to state 99
    NEWLINE         reduce using rule 93 (empty -> .)

    optend                         shift and go to state 95
    sep                            shift and go to state 96
    empty                          shift and go to state 97

state 55

    (88) plist -> pitem .
    ;               reduce using rule 88 (plist -> pitem .)
    ,               reduce using rule 88 (plist -> pitem .)
    NEWLINE         reduce using rule 88 (plist -> pitem .)


state 56

    (89) pitem -> expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    ;               reduce using rule 89 (pitem -> expr .)
    ,               reduce using rule 89 (pitem -> expr .)
    NEWLINE         reduce using rule 89 (pitem -> expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 57

    (90) pitem -> STRING . expr
    (56) expr -> STRING .
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
  ! shift/reduce conflict for - resolved as shift
    ^               reduce using rule 56 (expr -> STRING .)
    /               reduce using rule 56 (expr -> STRING .)
    *               reduce using rule 56 (expr -> STRING .)
    +               reduce using rule 56 (expr -> STRING .)
    ;               reduce using rule 56 (expr -> STRING .)
    ,               reduce using rule 56 (expr -> STRING .)
    NEWLINE         reduce using rule 56 (expr -> STRING .)
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 100
    variable                       shift and go to state 47

state 58

    (32) command -> INPUT error .
    NEWLINE         reduce using rule 32 (command -> INPUT error .)


state 59

    (33) command -> INPUT _1_STRING_sep_optional . varlist
    (81) varlist -> . varlist , variable
    (82) varlist -> . variable
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    IDENT           shift and go to state 50

    varlist                        shift and go to state 101
    variable                       shift and go to state 71

state 60

    (34) _1_STRING_sep_optional -> STRING . sep
    (91) sep -> . ;
    (92) sep -> . ,
    ;               shift and go to state 98
    ,               shift and go to state 99

    sep                            shift and go to state 102

state 61

    (36) command -> DATA error .
    NEWLINE         reduce using rule 36 (command -> DATA error .)


state 62

    (37) command -> DATA mixedlist .
    (44) mixedlist -> mixedlist . , mixeditem
    NEWLINE         reduce using rule 37 (command -> DATA mixedlist .)
    ,               shift and go to state 103


state 63

    (45) mixedlist -> mixeditem .
    ,               reduce using rule 45 (mixedlist -> mixeditem .)
    NEWLINE         reduce using rule 45 (mixedlist -> mixeditem .)


state 64

    (46) mixeditem -> STRING .
    ,               reduce using rule 46 (mixeditem -> STRING .)
    NEWLINE         reduce using rule 46 (mixeditem -> STRING .)


state 65

    (47) mixeditem -> number .
    ,               reduce using rule 47 (mixeditem -> number .)
    NEWLINE         reduce using rule 47 (mixeditem -> number .)


state 66

    (83) number -> - . FLOAT
    (84) number -> - . INTEGER
    FLOAT           shift and go to state 104
    INTEGER         shift and go to state 105


state 67

    (85) number -> FLOAT .
    ,               reduce using rule 85 (number -> FLOAT .)
    NEWLINE         reduce using rule 85 (number -> FLOAT .)


state 68

    (86) number -> INTEGER .
    ,               reduce using rule 86 (number -> INTEGER .)
    NEWLINE         reduce using rule 86 (number -> INTEGER .)


state 69

    (38) command -> READ error .
    NEWLINE         reduce using rule 38 (command -> READ error .)


state 70

    (40) command -> READ varlist .
    (81) varlist -> varlist . , variable
    NEWLINE         reduce using rule 40 (command -> READ varlist .)
    ,               shift and go to state 106


state 71

    (82) varlist -> variable .
    ,               reduce using rule 82 (varlist -> variable .)
    NEWLINE         reduce using rule 82 (varlist -> variable .)


state 72

    (41) command -> LET variable . = error
    (42) command -> LET variable . = expr
    =               shift and go to state 107


state 73

    (79) dimlist -> dimlist , . dimitem
    (77) dimitem -> . IDENT ( INTEGER , INTEGER )
    (78) dimitem -> . IDENT ( INTEGER )
    IDENT           shift and go to state 32

    dimitem                        shift and go to state 108

state 74

    (77) dimitem -> IDENT ( . INTEGER , INTEGER )
    (78) dimitem -> IDENT ( . INTEGER )
    INTEGER         shift and go to state 109


state 75

    (13) command -> DEF FNAME ( . error ) = expr
    (14) command -> DEF FNAME ( . IDENT ) = error
    (15) command -> DEF FNAME ( . IDENT ) = expr
    error           shift and go to state 110
    IDENT           shift and go to state 111


state 76

    (21) command -> FOR IDENT = . expr TO error optstep
    (22) command -> FOR IDENT = . error TO expr optstep
    (23) command -> FOR IDENT = . expr TO expr optstep
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    error           shift and go to state 113
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 112
    variable                       shift and go to state 47

state 77

    (24) command -> IF error THEN . INTEGER
    INTEGER         shift and go to state 114


state 78

    (25) command -> IF relexpr THEN . error
    (26) command -> IF relexpr THEN . INTEGER
    error           shift and go to state 115
    INTEGER         shift and go to state 116


state 79

    (66) relexpr -> expr NE . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 117
    variable                       shift and go to state 47

state 80

    (67) relexpr -> expr = . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 118
    variable                       shift and go to state 47

state 81

    (68) relexpr -> expr GE . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 119
    variable                       shift and go to state 47

state 82

    (69) relexpr -> expr GT . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 120
    variable                       shift and go to state 47

state 83

    (70) relexpr -> expr LE . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 121
    variable                       shift and go to state 47

state 84

    (71) relexpr -> expr LT . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 122
    variable                       shift and go to state 47

state 85

    (59) expr -> expr ^ . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 123
    variable                       shift and go to state 47

state 86

    (60) expr -> expr / . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 124
    variable                       shift and go to state 47

state 87

    (61) expr -> expr * . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 125
    variable                       shift and go to state 47

state 88

    (62) expr -> expr - . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 126
    variable                       shift and go to state 47

state 89

    (63) expr -> expr + . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 127
    variable                       shift and go to state 47

state 90

    (50) expr -> - expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NE              reduce using rule 50 (expr -> - expr .)
    =               reduce using rule 50 (expr -> - expr .)
    GE              reduce using rule 50 (expr -> - expr .)
    GT              reduce using rule 50 (expr -> - expr .)
    LE              reduce using rule 50 (expr -> - expr .)
    LT              reduce using rule 50 (expr -> - expr .)
    ^               reduce using rule 50 (expr -> - expr .)
    /               reduce using rule 50 (expr -> - expr .)
    *               reduce using rule 50 (expr -> - expr .)
    -               reduce using rule 50 (expr -> - expr .)
    +               reduce using rule 50 (expr -> - expr .)
    ;               reduce using rule 50 (expr -> - expr .)
    ,               reduce using rule 50 (expr -> - expr .)
    NEWLINE         reduce using rule 50 (expr -> - expr .)
    )               reduce using rule 50 (expr -> - expr .)
    TO              reduce using rule 50 (expr -> - expr .)
    THEN            reduce using rule 50 (expr -> - expr .)
    STEP            reduce using rule 50 (expr -> - expr .)


state 91

    (51) expr -> ( expr . )
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    )               shift and go to state 128
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 92

    (52) expr -> FNAME ( . exprlist )
    (64) exprlist -> . exprlist , expr
    (65) exprlist -> . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    exprlist                       shift and go to state 129
    expr                           shift and go to state 130
    variable                       shift and go to state 47

state 93

    (53) expr -> BLTIN ( . exprlist )
    (54) expr -> BLTIN ( . )
    (64) exprlist -> . exprlist , expr
    (65) exprlist -> . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    )               shift and go to state 132
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    exprlist                       shift and go to state 131
    expr                           shift and go to state 130
    variable                       shift and go to state 47

state 94

    (72) variable -> IDENT ( . expr , expr )
    (73) variable -> IDENT ( . expr )
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 133
    variable                       shift and go to state 47

state 95

    (31) command -> PRINT plist optend .
    NEWLINE         reduce using rule 31 (command -> PRINT plist optend .)


state 96

    (87) plist -> plist sep . pitem
    (49) optend -> sep .
    (89) pitem -> . expr
    (90) pitem -> . STRING expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    NEWLINE         reduce using rule 49 (optend -> sep .)
    STRING          shift and go to state 57
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    pitem                          shift and go to state 134
    expr                           shift and go to state 56
    variable                       shift and go to state 47

state 97

    (48) optend -> empty .
    NEWLINE         reduce using rule 48 (optend -> empty .)


state 98

    (91) sep -> ; .
    STRING          reduce using rule 91 (sep -> ; .)
    -               reduce using rule 91 (sep -> ; .)
    (               reduce using rule 91 (sep -> ; .)
    FNAME           reduce using rule 91 (sep -> ; .)
    BLTIN           reduce using rule 91 (sep -> ; .)
    FLOAT           reduce using rule 91 (sep -> ; .)
    INTEGER         reduce using rule 91 (sep -> ; .)
    IDENT           reduce using rule 91 (sep -> ; .)
    NEWLINE         reduce using rule 91 (sep -> ; .)


state 99

    (92) sep -> , .
    STRING          reduce using rule 92 (sep -> , .)
    -               reduce using rule 92 (sep -> , .)
    (               reduce using rule 92 (sep -> , .)
    FNAME           reduce using rule 92 (sep -> , .)
    BLTIN           reduce using rule 92 (sep -> , .)
    FLOAT           reduce using rule 92 (sep -> , .)
    INTEGER         reduce using rule 92 (sep -> , .)
    IDENT           reduce using rule 92 (sep -> , .)
    NEWLINE         reduce using rule 92 (sep -> , .)


state 100

    (90) pitem -> STRING expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    ;               reduce using rule 90 (pitem -> STRING expr .)
    ,               reduce using rule 90 (pitem -> STRING expr .)
    NEWLINE         reduce using rule 90 (pitem -> STRING expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 101

    (33) command -> INPUT _1_STRING_sep_optional varlist .
    (81) varlist -> varlist . , variable
    NEWLINE         reduce using rule 33 (command -> INPUT _1_STRING_sep_optional varlist .)
    ,               shift and go to state 106


state 102

    (34) _1_STRING_sep_optional -> STRING sep .
    IDENT           reduce using rule 34 (_1_STRING_sep_optional -> STRING sep .)


state 103

    (44) mixedlist -> mixedlist , . mixeditem
    (46) mixeditem -> . STRING
    (47) mixeditem -> . number
    (83) number -> . - FLOAT
    (84) number -> . - INTEGER
    (85) number -> . FLOAT
    (86) number -> . INTEGER
    STRING          shift and go to state 64
    -               shift and go to state 66
    FLOAT           shift and go to state 67
    INTEGER         shift and go to state 68

    mixeditem                      shift and go to state 135
    number                         shift and go to state 65

state 104

    (83) number -> - FLOAT .
    ,               reduce using rule 83 (number -> - FLOAT .)
    NEWLINE         reduce using rule 83 (number -> - FLOAT .)


state 105

    (84) number -> - INTEGER .
    ,               reduce using rule 84 (number -> - INTEGER .)
    NEWLINE         reduce using rule 84 (number -> - INTEGER .)


state 106

    (81) varlist -> varlist , . variable
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    IDENT           shift and go to state 50

    variable                       shift and go to state 136

state 107

    (41) command -> LET variable = . error
    (42) command -> LET variable = . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    error           shift and go to state 137
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    variable                       shift and go to state 47
    expr                           shift and go to state 138

state 108

    (79) dimlist -> dimlist , dimitem .
    ,               reduce using rule 79 (dimlist -> dimlist , dimitem .)
    NEWLINE         reduce using rule 79 (dimlist -> dimlist , dimitem .)


state 109

    (77) dimitem -> IDENT ( INTEGER . , INTEGER )
    (78) dimitem -> IDENT ( INTEGER . )
    ,               shift and go to state 139
    )               shift and go to state 140


state 110

    (13) command -> DEF FNAME ( error . ) = expr
    )               shift and go to state 141


state 111

    (14) command -> DEF FNAME ( IDENT . ) = error
    (15) command -> DEF FNAME ( IDENT . ) = expr
    )               shift and go to state 142


state 112

    (21) command -> FOR IDENT = expr . TO error optstep
    (23) command -> FOR IDENT = expr . TO expr optstep
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    TO              shift and go to state 143
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 113

    (22) command -> FOR IDENT = error . TO expr optstep
    TO              shift and go to state 144


state 114

    (24) command -> IF error THEN INTEGER .
    NEWLINE         reduce using rule 24 (command -> IF error THEN INTEGER .)


state 115

    (25) command -> IF relexpr THEN error .
    NEWLINE         reduce using rule 25 (command -> IF relexpr THEN error .)


state 116

    (26) command -> IF relexpr THEN INTEGER .
    NEWLINE         reduce using rule 26 (command -> IF relexpr THEN INTEGER .)


state 117

    (66) relexpr -> expr NE expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    THEN            reduce using rule 66 (relexpr -> expr NE expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 118

    (67) relexpr -> expr = expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    THEN            reduce using rule 67 (relexpr -> expr = expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 119

    (68) relexpr -> expr GE expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    THEN            reduce using rule 68 (relexpr -> expr GE expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 120

    (69) relexpr -> expr GT expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    THEN            reduce using rule 69 (relexpr -> expr GT expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 121

    (70) relexpr -> expr LE expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    THEN            reduce using rule 70 (relexpr -> expr LE expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 122

    (71) relexpr -> expr LT expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    THEN            reduce using rule 71 (relexpr -> expr LT expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 123

    (59) expr -> expr ^ expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NE              reduce using rule 59 (expr -> expr ^ expr .)
    =               reduce using rule 59 (expr -> expr ^ expr .)
    GE              reduce using rule 59 (expr -> expr ^ expr .)
    GT              reduce using rule 59 (expr -> expr ^ expr .)
    LE              reduce using rule 59 (expr -> expr ^ expr .)
    LT              reduce using rule 59 (expr -> expr ^ expr .)
    ^               reduce using rule 59 (expr -> expr ^ expr .)
    /               reduce using rule 59 (expr -> expr ^ expr .)
    *               reduce using rule 59 (expr -> expr ^ expr .)
    -               reduce using rule 59 (expr -> expr ^ expr .)
    +               reduce using rule 59 (expr -> expr ^ expr .)
    ;               reduce using rule 59 (expr -> expr ^ expr .)
    ,               reduce using rule 59 (expr -> expr ^ expr .)
    NEWLINE         reduce using rule 59 (expr -> expr ^ expr .)
    )               reduce using rule 59 (expr -> expr ^ expr .)
    TO              reduce using rule 59 (expr -> expr ^ expr .)
    THEN            reduce using rule 59 (expr -> expr ^ expr .)
    STEP            reduce using rule 59 (expr -> expr ^ expr .)


state 124

    (60) expr -> expr / expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NE              reduce using rule 60 (expr -> expr / expr .)
    =               reduce using rule 60 (expr -> expr / expr .)
    GE              reduce using rule 60 (expr -> expr / expr .)
    GT              reduce using rule 60 (expr -> expr / expr .)
    LE              reduce using rule 60 (expr -> expr / expr .)
    LT              reduce using rule 60 (expr -> expr / expr .)
    /               reduce using rule 60 (expr -> expr / expr .)
    *               reduce using rule 60 (expr -> expr / expr .)
    -               reduce using rule 60 (expr -> expr / expr .)
    +               reduce using rule 60 (expr -> expr / expr .)
    ;               reduce using rule 60 (expr -> expr / expr .)
    ,               reduce using rule 60 (expr -> expr / expr .)
    NEWLINE         reduce using rule 60 (expr -> expr / expr .)
    )               reduce using rule 60 (expr -> expr / expr .)
    TO              reduce using rule 60 (expr -> expr / expr .)
    THEN            reduce using rule 60 (expr -> expr / expr .)
    STEP            reduce using rule 60 (expr -> expr / expr .)
    ^               shift and go to state 85


state 125

    (61) expr -> expr * expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NE              reduce using rule 61 (expr -> expr * expr .)
    =               reduce using rule 61 (expr -> expr * expr .)
    GE              reduce using rule 61 (expr -> expr * expr .)
    GT              reduce using rule 61 (expr -> expr * expr .)
    LE              reduce using rule 61 (expr -> expr * expr .)
    LT              reduce using rule 61 (expr -> expr * expr .)
    /               reduce using rule 61 (expr -> expr * expr .)
    *               reduce using rule 61 (expr -> expr * expr .)
    -               reduce using rule 61 (expr -> expr * expr .)
    +               reduce using rule 61 (expr -> expr * expr .)
    ;               reduce using rule 61 (expr -> expr * expr .)
    ,               reduce using rule 61 (expr -> expr * expr .)
    NEWLINE         reduce using rule 61 (expr -> expr * expr .)
    )               reduce using rule 61 (expr -> expr * expr .)
    TO              reduce using rule 61 (expr -> expr * expr .)
    THEN            reduce using rule 61 (expr -> expr * expr .)
    STEP            reduce using rule 61 (expr -> expr * expr .)
    ^               shift and go to state 85


state 126

    (62) expr -> expr - expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NE              reduce using rule 62 (expr -> expr - expr .)
    =               reduce using rule 62 (expr -> expr - expr .)
    GE              reduce using rule 62 (expr -> expr - expr .)
    GT              reduce using rule 62 (expr -> expr - expr .)
    LE              reduce using rule 62 (expr -> expr - expr .)
    LT              reduce using rule 62 (expr -> expr - expr .)
    -               reduce using rule 62 (expr -> expr - expr .)
    +               reduce using rule 62 (expr -> expr - expr .)
    ;               reduce using rule 62 (expr -> expr - expr .)
    ,               reduce using rule 62 (expr -> expr - expr .)
    NEWLINE         reduce using rule 62 (expr -> expr - expr .)
    )               reduce using rule 62 (expr -> expr - expr .)
    TO              reduce using rule 62 (expr -> expr - expr .)
    THEN            reduce using rule 62 (expr -> expr - expr .)
    STEP            reduce using rule 62 (expr -> expr - expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87


state 127

    (63) expr -> expr + expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NE              reduce using rule 63 (expr -> expr + expr .)
    =               reduce using rule 63 (expr -> expr + expr .)
    GE              reduce using rule 63 (expr -> expr + expr .)
    GT              reduce using rule 63 (expr -> expr + expr .)
    LE              reduce using rule 63 (expr -> expr + expr .)
    LT              reduce using rule 63 (expr -> expr + expr .)
    -               reduce using rule 63 (expr -> expr + expr .)
    +               reduce using rule 63 (expr -> expr + expr .)
    ;               reduce using rule 63 (expr -> expr + expr .)
    ,               reduce using rule 63 (expr -> expr + expr .)
    NEWLINE         reduce using rule 63 (expr -> expr + expr .)
    )               reduce using rule 63 (expr -> expr + expr .)
    TO              reduce using rule 63 (expr -> expr + expr .)
    THEN            reduce using rule 63 (expr -> expr + expr .)
    STEP            reduce using rule 63 (expr -> expr + expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87


state 128

    (51) expr -> ( expr ) .
    NE              reduce using rule 51 (expr -> ( expr ) .)
    =               reduce using rule 51 (expr -> ( expr ) .)
    GE              reduce using rule 51 (expr -> ( expr ) .)
    GT              reduce using rule 51 (expr -> ( expr ) .)
    LE              reduce using rule 51 (expr -> ( expr ) .)
    LT              reduce using rule 51 (expr -> ( expr ) .)
    ^               reduce using rule 51 (expr -> ( expr ) .)
    /               reduce using rule 51 (expr -> ( expr ) .)
    *               reduce using rule 51 (expr -> ( expr ) .)
    -               reduce using rule 51 (expr -> ( expr ) .)
    +               reduce using rule 51 (expr -> ( expr ) .)
    ;               reduce using rule 51 (expr -> ( expr ) .)
    ,               reduce using rule 51 (expr -> ( expr ) .)
    NEWLINE         reduce using rule 51 (expr -> ( expr ) .)
    )               reduce using rule 51 (expr -> ( expr ) .)
    TO              reduce using rule 51 (expr -> ( expr ) .)
    THEN            reduce using rule 51 (expr -> ( expr ) .)
    STEP            reduce using rule 51 (expr -> ( expr ) .)


state 129

    (52) expr -> FNAME ( exprlist . )
    (64) exprlist -> exprlist . , expr
    )               shift and go to state 145
    ,               shift and go to state 146


state 130

    (65) exprlist -> expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    )               reduce using rule 65 (exprlist -> expr .)
    ,               reduce using rule 65 (exprlist -> expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 131

    (53) expr -> BLTIN ( exprlist . )
    (64) exprlist -> exprlist . , expr
    )               shift and go to state 147
    ,               shift and go to state 146


state 132

    (54) expr -> BLTIN ( ) .
    NE              reduce using rule 54 (expr -> BLTIN ( ) .)
    =               reduce using rule 54 (expr -> BLTIN ( ) .)
    GE              reduce using rule 54 (expr -> BLTIN ( ) .)
    GT              reduce using rule 54 (expr -> BLTIN ( ) .)
    LE              reduce using rule 54 (expr -> BLTIN ( ) .)
    LT              reduce using rule 54 (expr -> BLTIN ( ) .)
    ^               reduce using rule 54 (expr -> BLTIN ( ) .)
    /               reduce using rule 54 (expr -> BLTIN ( ) .)
    *               reduce using rule 54 (expr -> BLTIN ( ) .)
    -               reduce using rule 54 (expr -> BLTIN ( ) .)
    +               reduce using rule 54 (expr -> BLTIN ( ) .)
    ;               reduce using rule 54 (expr -> BLTIN ( ) .)
    ,               reduce using rule 54 (expr -> BLTIN ( ) .)
    NEWLINE         reduce using rule 54 (expr -> BLTIN ( ) .)
    )               reduce using rule 54 (expr -> BLTIN ( ) .)
    TO              reduce using rule 54 (expr -> BLTIN ( ) .)
    THEN            reduce using rule 54 (expr -> BLTIN ( ) .)
    STEP            reduce using rule 54 (expr -> BLTIN ( ) .)


state 133

    (72) variable -> IDENT ( expr . , expr )
    (73) variable -> IDENT ( expr . )
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    ,               shift and go to state 148
    )               shift and go to state 149
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 134

    (87) plist -> plist sep pitem .
    ;               reduce using rule 87 (plist -> plist sep pitem .)
    ,               reduce using rule 87 (plist -> plist sep pitem .)
    NEWLINE         reduce using rule 87 (plist -> plist sep pitem .)


state 135

    (44) mixedlist -> mixedlist , mixeditem .
    ,               reduce using rule 44 (mixedlist -> mixedlist , mixeditem .)
    NEWLINE         reduce using rule 44 (mixedlist -> mixedlist , mixeditem .)


state 136

    (81) varlist -> varlist , variable .
    ,               reduce using rule 81 (varlist -> varlist , variable .)
    NEWLINE         reduce using rule 81 (varlist -> varlist , variable .)


state 137

    (41) command -> LET variable = error .
    NEWLINE         reduce using rule 41 (command -> LET variable = error .)


state 138

    (42) command -> LET variable = expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NEWLINE         reduce using rule 42 (command -> LET variable = expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 139

    (77) dimitem -> IDENT ( INTEGER , . INTEGER )
    INTEGER         shift and go to state 150


state 140

    (78) dimitem -> IDENT ( INTEGER ) .
    ,               reduce using rule 78 (dimitem -> IDENT ( INTEGER ) .)
    NEWLINE         reduce using rule 78 (dimitem -> IDENT ( INTEGER ) .)


state 141

    (13) command -> DEF FNAME ( error ) . = expr
    =               shift and go to state 151


state 142

    (14) command -> DEF FNAME ( IDENT ) . = error
    (15) command -> DEF FNAME ( IDENT ) . = expr
    =               shift and go to state 152


state 143

    (21) command -> FOR IDENT = expr TO . error optstep
    (23) command -> FOR IDENT = expr TO . expr optstep
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    error           shift and go to state 154
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 153
    variable                       shift and go to state 47

state 144

    (22) command -> FOR IDENT = error TO . expr optstep
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 155
    variable                       shift and go to state 47

state 145

    (52) expr -> FNAME ( exprlist ) .
    NE              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    =               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    GE              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    GT              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    LE              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    LT              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    ^               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    /               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    *               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    -               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    +               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    ;               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    ,               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    NEWLINE         reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    )               reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    TO              reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    THEN            reduce using rule 52 (expr -> FNAME ( exprlist ) .)
    STEP            reduce using rule 52 (expr -> FNAME ( exprlist ) .)


state 146

    (64) exprlist -> exprlist , . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 156
    variable                       shift and go to state 47

state 147

    (53) expr -> BLTIN ( exprlist ) .
    NE              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    =               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    GE              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    GT              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    LE              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    LT              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    ^               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    /               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    *               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    -               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    +               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    ;               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    ,               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    NEWLINE         reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    )               reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    TO              reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    THEN            reduce using rule 53 (expr -> BLTIN ( exprlist ) .)
    STEP            reduce using rule 53 (expr -> BLTIN ( exprlist ) .)


state 148

    (72) variable -> IDENT ( expr , . expr )
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 157
    variable                       shift and go to state 47

state 149

    (73) variable -> IDENT ( expr ) .
    NE              reduce using rule 73 (variable -> IDENT ( expr ) .)
    =               reduce using rule 73 (variable -> IDENT ( expr ) .)
    GE              reduce using rule 73 (variable -> IDENT ( expr ) .)
    GT              reduce using rule 73 (variable -> IDENT ( expr ) .)
    LE              reduce using rule 73 (variable -> IDENT ( expr ) .)
    LT              reduce using rule 73 (variable -> IDENT ( expr ) .)
    ^               reduce using rule 73 (variable -> IDENT ( expr ) .)
    /               reduce using rule 73 (variable -> IDENT ( expr ) .)
    *               reduce using rule 73 (variable -> IDENT ( expr ) .)
    -               reduce using rule 73 (variable -> IDENT ( expr ) .)
    +               reduce using rule 73 (variable -> IDENT ( expr ) .)
    ;               reduce using rule 73 (variable -> IDENT ( expr ) .)
    ,               reduce using rule 73 (variable -> IDENT ( expr ) .)
    NEWLINE         reduce using rule 73 (variable -> IDENT ( expr ) .)
    )               reduce using rule 73 (variable -> IDENT ( expr ) .)
    TO              reduce using rule 73 (variable -> IDENT ( expr ) .)
    THEN            reduce using rule 73 (variable -> IDENT ( expr ) .)
    STEP            reduce using rule 73 (variable -> IDENT ( expr ) .)


state 150

    (77) dimitem -> IDENT ( INTEGER , INTEGER . )
    )               shift and go to state 158


state 151

    (13) command -> DEF FNAME ( error ) = . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 159
    variable                       shift and go to state 47

state 152

    (14) command -> DEF FNAME ( IDENT ) = . error
    (15) command -> DEF FNAME ( IDENT ) = . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    error           shift and go to state 160
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 161
    variable                       shift and go to state 47

state 153

    (23) command -> FOR IDENT = expr TO expr . optstep
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    (75) optstep -> . empty
    (76) optstep -> . STEP expr
    (93) empty -> .
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89
    STEP            shift and go to state 164
    NEWLINE         reduce using rule 93 (empty -> .)

    optstep                        shift and go to state 162
    empty                          shift and go to state 163

state 154

    (21) command -> FOR IDENT = expr TO error . optstep
    (75) optstep -> . empty
    (76) optstep -> . STEP expr
    (93) empty -> .
    STEP            shift and go to state 164
    NEWLINE         reduce using rule 93 (empty -> .)

    optstep                        shift and go to state 165
    empty                          shift and go to state 163

state 155

    (22) command -> FOR IDENT = error TO expr . optstep
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    (75) optstep -> . empty
    (76) optstep -> . STEP expr
    (93) empty -> .
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89
    STEP            shift and go to state 164
    NEWLINE         reduce using rule 93 (empty -> .)

    optstep                        shift and go to state 166
    empty                          shift and go to state 163

state 156

    (64) exprlist -> exprlist , expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    )               reduce using rule 64 (exprlist -> exprlist , expr .)
    ,               reduce using rule 64 (exprlist -> exprlist , expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 157

    (72) variable -> IDENT ( expr , expr . )
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    )               shift and go to state 167
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 158

    (77) dimitem -> IDENT ( INTEGER , INTEGER ) .
    ,               reduce using rule 77 (dimitem -> IDENT ( INTEGER , INTEGER ) .)
    NEWLINE         reduce using rule 77 (dimitem -> IDENT ( INTEGER , INTEGER ) .)


state 159

    (13) command -> DEF FNAME ( error ) = expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NEWLINE         reduce using rule 13 (command -> DEF FNAME ( error ) = expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 160

    (14) command -> DEF FNAME ( IDENT ) = error .
    NEWLINE         reduce using rule 14 (command -> DEF FNAME ( IDENT ) = error .)


state 161

    (15) command -> DEF FNAME ( IDENT ) = expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NEWLINE         reduce using rule 15 (command -> DEF FNAME ( IDENT ) = expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


state 162

    (23) command -> FOR IDENT = expr TO expr optstep .
    NEWLINE         reduce using rule 23 (command -> FOR IDENT = expr TO expr optstep .)


state 163

    (75) optstep -> empty .
    NEWLINE         reduce using rule 75 (optstep -> empty .)


state 164

    (76) optstep -> STEP . expr
    (50) expr -> . - expr
    (51) expr -> . ( expr )
    (52) expr -> . FNAME ( exprlist )
    (53) expr -> . BLTIN ( exprlist )
    (54) expr -> . BLTIN ( )
    (55) expr -> . variable
    (56) expr -> . STRING
    (57) expr -> . FLOAT
    (58) expr -> . INTEGER
    (59) expr -> . expr ^ expr
    (60) expr -> . expr / expr
    (61) expr -> . expr * expr
    (62) expr -> . expr - expr
    (63) expr -> . expr + expr
    (72) variable -> . IDENT ( expr , expr )
    (73) variable -> . IDENT ( expr )
    (74) variable -> . IDENT
    -               shift and go to state 43
    (               shift and go to state 44
    FNAME           shift and go to state 45
    BLTIN           shift and go to state 46
    STRING          shift and go to state 48
    FLOAT           shift and go to state 49
    INTEGER         shift and go to state 40
    IDENT           shift and go to state 50

    expr                           shift and go to state 168
    variable                       shift and go to state 47

state 165

    (21) command -> FOR IDENT = expr TO error optstep .
    NEWLINE         reduce using rule 21 (command -> FOR IDENT = expr TO error optstep .)


state 166

    (22) command -> FOR IDENT = error TO expr optstep .
    NEWLINE         reduce using rule 22 (command -> FOR IDENT = error TO expr optstep .)


state 167

    (72) variable -> IDENT ( expr , expr ) .
    NE              reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    =               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    GE              reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    GT              reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    LE              reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    LT              reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    ^               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    /               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    *               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    -               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    +               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    ;               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    ,               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    NEWLINE         reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    )               reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    TO              reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    THEN            reduce using rule 72 (variable -> IDENT ( expr , expr ) .)
    STEP            reduce using rule 72 (variable -> IDENT ( expr , expr ) .)


state 168

    (76) optstep -> STEP expr .
    (59) expr -> expr . ^ expr
    (60) expr -> expr . / expr
    (61) expr -> expr . * expr
    (62) expr -> expr . - expr
    (63) expr -> expr . + expr
    NEWLINE         reduce using rule 76 (optstep -> STEP expr .)
    ^               shift and go to state 85
    /               shift and go to state 86
    *               shift and go to state 87
    -               shift and go to state 88
    +               shift and go to state 89


Conflicts:

shift/reduce conflict for NEWLINE in state 9 resolved as shift
shift/reduce conflict for - in state 57 resolved as shift